<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Python 魔法方法 指南" /><meta property="og:locale" content="en_US" /><meta name="description" content="什么是魔法方法呢？魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。它们经常是两个下划线包围来命名的（比如__init__， __lt__ ）" /><meta property="og:description" content="什么是魔法方法呢？魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。它们经常是两个下划线包围来命名的（比如__init__， __lt__ ）" /><link rel="canonical" href="https://justzxy.cn/posts/python-magic/" /><meta property="og:url" content="https://justzxy.cn/posts/python-magic/" /><meta property="og:site_name" content="图样图森破" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-09-20T17:41:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Python 魔法方法 指南" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"什么是魔法方法呢？魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。它们经常是两个下划线包围来命名的（比如__init__， __lt__ ）","url":"https://justzxy.cn/posts/python-magic/","headline":"Python 魔法方法 指南","dateModified":"2021-07-19T23:50:50+08:00","datePublished":"2019-09-20T17:41:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://justzxy.cn/posts/python-magic/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Python 魔法方法 指南 | 图样图森破</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="图样图森破"><meta name="application-name" content="图样图森破"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">图样图森破</a></div><div class="site-subtitle font-italic">Too Young Too Simple</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Python 魔法方法 指南</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Python 魔法方法 指南</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tooYoungtooSimple </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Sep 20, 2019, 5:41 PM +0800" prep="on" > Sep 20, 2019 <i class="unloaded">2019-09-20T17:41:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jul 19, 2021, 11:50 PM +0800" prefix="Updated " > Jul 19 <i class="unloaded">2021-07-19T23:50:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7720 words">42 min</span></div></div><div class="post-content"><p>什么是魔法方法呢？魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。它们经常是两个下划线包围来命名的（比如__init__， __lt__ ）</p><ul id="markdown-toc"><li><a href="#ⅰ-构造方法" id="markdown-toc-ⅰ-构造方法">Ⅰ. 构造方法</a><ul><li><a href="#__new__cls-" id="markdown-toc-__new__cls-">__new__（cls, […]）</a><li><a href="#__init__self-" id="markdown-toc-__init__self-">__init__（self, […]）</a><li><a href="#__del__self" id="markdown-toc-__del__self">__del__（self）</a></ul><li><a href="#ⅱ-比较操作符" id="markdown-toc-ⅱ-比较操作符">Ⅱ. 比较操作符</a><ul><li><a href="#__cmp__self-other" id="markdown-toc-__cmp__self-other">__cmp__(self, other)</a><li><a href="#__eq__self-other" id="markdown-toc-__eq__self-other">__eq__(self, other)</a><li><a href="#__ne__self-other" id="markdown-toc-__ne__self-other">__ne__(self, other)</a><li><a href="#__lt__self-other" id="markdown-toc-__lt__self-other">__lt__(self, other)</a><li><a href="#__gt__self-other" id="markdown-toc-__gt__self-other">__gt__(self, other)</a><li><a href="#__le__self-other" id="markdown-toc-__le__self-other">__le__(self, other)</a><li><a href="#__ge__self-other" id="markdown-toc-__ge__self-other">__ge__(self, other)</a></ul><li><a href="#ⅲ-一元操作符" id="markdown-toc-ⅲ-一元操作符">Ⅲ. 一元操作符</a><ul><li><a href="#__pos__self" id="markdown-toc-__pos__self">__pos__(self)</a><li><a href="#__neg__self" id="markdown-toc-__neg__self">__neg__(self)</a><li><a href="#__abs__self" id="markdown-toc-__abs__self">__abs__(self)</a><li><a href="#__invert__self" id="markdown-toc-__invert__self">__invert__(self)</a><li><a href="#__round__self-n" id="markdown-toc-__round__self-n">__round__(self， n)</a><li><a href="#__floor__self" id="markdown-toc-__floor__self">__floor__(self)</a><li><a href="#__ceil__self" id="markdown-toc-__ceil__self">__ceil__(self)</a><li><a href="#__trunc__self" id="markdown-toc-__trunc__self">__trunc__(self)</a></ul><li><a href="#ⅳ-算术操作符" id="markdown-toc-ⅳ-算术操作符">Ⅳ. 算术操作符</a><ul><li><a href="#__add__self-other" id="markdown-toc-__add__self-other">__add__(self, other)</a><li><a href="#__sub__self-other" id="markdown-toc-__sub__self-other">__sub__(self, other)</a><li><a href="#__mul__self-other" id="markdown-toc-__mul__self-other">__mul__(self, other)</a><li><a href="#__floordiv__self-other" id="markdown-toc-__floordiv__self-other">__floordiv__(self, other)</a><li><a href="#__div__self-other" id="markdown-toc-__div__self-other">__div__(self, other)</a><li><a href="#__truediv__self-other" id="markdown-toc-__truediv__self-other">__truediv__(self, other)</a><li><a href="#__mod__self-other" id="markdown-toc-__mod__self-other">__mod__(self, other)</a><li><a href="#__divmod__self-other" id="markdown-toc-__divmod__self-other">__divmod__(self, other)</a><li><a href="#__pow__" id="markdown-toc-__pow__">__pow__</a><li><a href="#__lshift__self-other" id="markdown-toc-__lshift__self-other">__lshift__(self, other)</a><li><a href="#__rshift__self-other" id="markdown-toc-__rshift__self-other">__rshift__(self, other)</a><li><a href="#__and__self-other" id="markdown-toc-__and__self-other">__and__(self, other)</a><li><a href="#__or__self-other" id="markdown-toc-__or__self-other">__or__(self, other)</a><li><a href="#__xor__self-other" id="markdown-toc-__xor__self-other">__xor__(self, other)</a></ul><li><a href="#ⅴ-反射算数运算符" id="markdown-toc-ⅴ-反射算数运算符">Ⅴ. 反射算数运算符</a><ul><li><a href="#__radd__self-other" id="markdown-toc-__radd__self-other">__radd__(self, other)</a><li><a href="#__rsub__self-other" id="markdown-toc-__rsub__self-other">__rsub__(self, other)</a><li><a href="#__rmul__self-other" id="markdown-toc-__rmul__self-other">__rmul__(self, other)</a><li><a href="#__rfloordiv__self-other" id="markdown-toc-__rfloordiv__self-other">__rfloordiv__(self, other)</a><li><a href="#__rdiv__self-other" id="markdown-toc-__rdiv__self-other">__rdiv__(self, other)</a><li><a href="#__rtruediv__self-other" id="markdown-toc-__rtruediv__self-other">__rtruediv__(self, other)</a><li><a href="#__rmod__self-other" id="markdown-toc-__rmod__self-other">__rmod__(self, other)</a><li><a href="#__rdivmod__self-other" id="markdown-toc-__rdivmod__self-other">__rdivmod__(self, other)</a><li><a href="#__rpow__" id="markdown-toc-__rpow__">__rpow__</a><li><a href="#__rlshift__self-other" id="markdown-toc-__rlshift__self-other">__rlshift__(self, other)</a><li><a href="#__rshift__self-other-1" id="markdown-toc-__rshift__self-other-1">__rshift__(self, other)</a><li><a href="#__rand__self-other" id="markdown-toc-__rand__self-other">__rand__(self, other)</a><li><a href="#__ror__self-other" id="markdown-toc-__ror__self-other">__ror__(self, other)</a><li><a href="#__rxor__self-other" id="markdown-toc-__rxor__self-other">__rxor__(self, other)</a></ul><li><a href="#ⅵ-增强赋值运算符" id="markdown-toc-ⅵ-增强赋值运算符">Ⅵ. 增强赋值运算符</a><ul><li><a href="#__iadd__self-other" id="markdown-toc-__iadd__self-other">__iadd__(self, other)</a><li><a href="#__isub__self-other" id="markdown-toc-__isub__self-other">__isub__(self, other)</a><li><a href="#__imul__self-other" id="markdown-toc-__imul__self-other">__imul__(self, other)</a><li><a href="#__ifloordiv__self-other" id="markdown-toc-__ifloordiv__self-other">__ifloordiv__(self, other)</a><li><a href="#__idiv__self-other" id="markdown-toc-__idiv__self-other">__idiv__(self, other)</a><li><a href="#__itruediv__self-other" id="markdown-toc-__itruediv__self-other">__itruediv__(self, other)</a><li><a href="#__imod__self-other" id="markdown-toc-__imod__self-other">__imod__(self, other)</a><li><a href="#__ipow__" id="markdown-toc-__ipow__">__ipow__</a><li><a href="#__ilshift__self-other" id="markdown-toc-__ilshift__self-other">__ilshift__(self, other)</a><li><a href="#__irshift__self-other" id="markdown-toc-__irshift__self-other">__irshift__(self, other)</a><li><a href="#__iand__self-other" id="markdown-toc-__iand__self-other">__iand__(self, other)</a><li><a href="#__ior__self-other" id="markdown-toc-__ior__self-other">__ior__(self, other)</a><li><a href="#__ixor__self-other" id="markdown-toc-__ixor__self-other">__ixor__(self, other)</a></ul><li><a href="#ⅶ-类型转换操作符" id="markdown-toc-ⅶ-类型转换操作符">Ⅶ. 类型转换操作符</a><ul><li><a href="#__int__self" id="markdown-toc-__int__self">__int__(self)</a><li><a href="#__long__self" id="markdown-toc-__long__self">__long__(self)</a><li><a href="#__float__self" id="markdown-toc-__float__self">__float__(self)</a><li><a href="#__complex__self" id="markdown-toc-__complex__self">__complex__(self)</a><li><a href="#__oct__self" id="markdown-toc-__oct__self">__oct__(self)</a><li><a href="#__hex__self" id="markdown-toc-__hex__self">__hex__(self)</a><li><a href="#__index__self" id="markdown-toc-__index__self">__index__(self)</a><li><a href="#__trunc__self-1" id="markdown-toc-__trunc__self-1">__trunc__(self)</a><li><a href="#__coerce__self" id="markdown-toc-__coerce__self">__coerce__(self)</a></ul><li><a href="#ⅷ-类的表示" id="markdown-toc-ⅷ-类的表示">Ⅷ. 类的表示</a><ul><li><a href="#__str__self" id="markdown-toc-__str__self">__str__(self)</a><li><a href="#__repr__self" id="markdown-toc-__repr__self">__repr__(self)</a><li><a href="#__unicode__self" id="markdown-toc-__unicode__self">__unicode__(self)</a><li><a href="#__format__self" id="markdown-toc-__format__self">__format__(self)</a><li><a href="#__hash__self" id="markdown-toc-__hash__self">__hash__(self)</a><li><a href="#__nonzero__self" id="markdown-toc-__nonzero__self">__nonzero__(self)</a><li><a href="#__dir__self" id="markdown-toc-__dir__self">__dir__(self)</a></ul><li><a href="#ⅸ-访问控制" id="markdown-toc-ⅸ-访问控制">Ⅸ. 访问控制</a><ul><li><a href="#__getattr__self-name" id="markdown-toc-__getattr__self-name">__getattr__(self, name)</a><li><a href="#__setattr__self-name-value" id="markdown-toc-__setattr__self-name-value">__setattr__(self, name, value)</a><li><a href="#__delattr__self-name" id="markdown-toc-__delattr__self-name">__delattr__(self, name)</a><li><a href="#__getattribute__self-name" id="markdown-toc-__getattribute__self-name">__getattribute__(self, name)</a></ul><li><a href="#ⅹ-自定义序列" id="markdown-toc-ⅹ-自定义序列">Ⅹ. 自定义序列</a><ul><li><a href="#__len__self" id="markdown-toc-__len__self">__len__(self)</a><li><a href="#__getitem__self-key" id="markdown-toc-__getitem__self-key">__getitem__(self, key)</a><li><a href="#__setitem__self-key" id="markdown-toc-__setitem__self-key">__setitem__(self, key)</a><li><a href="#__iter__self-key" id="markdown-toc-__iter__self-key">__iter__(self, key)</a><li><a href="#__reversed__self" id="markdown-toc-__reversed__self">__reversed__(self)</a><li><a href="#__contains__self-item" id="markdown-toc-__contains__self-item">__contains__(self, item)</a><li><a href="#__missing__self-key" id="markdown-toc-__missing__self-key">__missing__(self ,key)</a></ul><li><a href="#ⅺ-反射" id="markdown-toc-ⅺ-反射">Ⅺ. 反射</a><ul><li><a href="#__instancecheck__self-instance" id="markdown-toc-__instancecheck__self-instance">__instancecheck__(self, instance)</a><li><a href="#__subclasscheck__self-subclass" id="markdown-toc-__subclasscheck__self-subclass">__subclasscheck__(self, subclass)</a></ul><li><a href="#ⅻ-抽象基类" id="markdown-toc-ⅻ-抽象基类">Ⅻ. 抽象基类</a><ul><li><a href="#见参考文档-httpdocspythonorg2libraryabchtml" id="markdown-toc-见参考文档-httpdocspythonorg2libraryabchtml">见参考文档 http://docs.python.org/2/library/abc.html</a></ul><li><a href="#xiii-可调用的对象" id="markdown-toc-xiii-可调用的对象">XIII. 可调用的对象</a><ul><li><a href="#__call__self-args" id="markdown-toc-__call__self-args">__call__(self, [args…])</a></ul><li><a href="#xiv-上下文管理器" id="markdown-toc-xiv-上下文管理器">XIV. 上下文管理器</a><ul><li><a href="#__enter__self" id="markdown-toc-__enter__self">__enter__(self)</a><li><a href="#__exit__self-exception_type-exception_value-traceback" id="markdown-toc-__exit__self-exception_type-exception_value-traceback">__exit__(self, exception_type, exception_value, traceback)</a></ul><li><a href="#xv-创建描述符对象" id="markdown-toc-xv-创建描述符对象">XV. 创建描述符对象</a><ul><li><a href="#__get__self-instance-owner" id="markdown-toc-__get__self-instance-owner">__get__(self, instance, owner)</a><li><a href="#__set__self-instance-owner" id="markdown-toc-__set__self-instance-owner">__set__(self, instance, owner)</a><li><a href="#__delete__self-instance-owner" id="markdown-toc-__delete__self-instance-owner">__delete__(self, instance, owner)</a></ul><li><a href="#xvi-拷贝" id="markdown-toc-xvi-拷贝">XVI. 拷贝</a><ul><li><a href="#__copy__self" id="markdown-toc-__copy__self">__copy__(self)</a><li><a href="#__deepcopy__self-memodict" id="markdown-toc-__deepcopy__self-memodict">__deepcopy__(self, memodict=)</a></ul><li><a href="#xvii-pickling" id="markdown-toc-xvii-pickling">XVII. Pickling</a><ul><li><a href="#__getinitargs__self" id="markdown-toc-__getinitargs__self">__getinitargs__(self)</a><li><a href="#__getnewargs__self" id="markdown-toc-__getnewargs__self">__getnewargs__(self)</a><li><a href="#__getstate__self" id="markdown-toc-__getstate__self">__getstate__(self)</a><li><a href="#__setstate__self" id="markdown-toc-__setstate__self">__setstate__(self)</a><li><a href="#__reduce__self" id="markdown-toc-__reduce__self">__reduce__(self)</a><li><a href="#__reduce_ex__self" id="markdown-toc-__reduce_ex__self">__reduce_ex__(self)</a></ul><li><a href="#附录1-如何调用魔法方法" id="markdown-toc-附录1-如何调用魔法方法">附录1. 如何调用魔法方法</a><li><a href="#附录2-python-3中的变化" id="markdown-toc-附录2-python-3中的变化">附录2. Python 3中的变化</a></ul><h2 id="ⅰ-构造方法">Ⅰ. 构造方法</h2><p>__init__指明一个对象初始化的行为，然而，当我们调用 x = SomeClass() 的时候，__init__并不是第一个被调用的方法。事实上，第一个被调用的是__new__，这个 方法才真正地创建了实例。当这个对象的生命周期结束的时候， __del__会被调用。</p><h3 id="__new__cls-">__new__（cls, […]）</h3><p>__new__是对象实例化时第一个调用的方法，它只取下 cls 参数，并把其他参数传给__init__。单例类场景可以重写此方法，美多项目短信验证功能有用到</p><h3 id="__init__self-">__init__（self, […]）</h3><p>类的初始化方法。它获取任何传给构造器的参数（比如我们调用 x = SomeClass(10, ‘foo’) ，__init__就会接到参数 10 和 ‘foo’ 。__init__ 在Python的类定义中用的最多。</p><h3 id="__del__self">__del__（self）</h3><p>__new__ 和 __init__ 是对象的构造器， __del__ 是对象的销毁器。它并非实现了语句 del x (因此该语句不等同于 x.__del__())。而是定义了当对象被垃圾回收时的行为。 当对象需要在销毁时做一些处理的时候这个方法很有用，比如 socket 对象、文件对象。但是需要注意的是，当Python解释器退出但对象仍然存活的时候， __del__ 并不会 执行。 所以养成一个手工清理的好习惯是很重要的，比如及时关闭连接。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span>

<span class="k">class</span> <span class="nc">FileObject</span><span class="p">:</span>
    <span class="s">'''文件对象的装饰类，用来保证文件被删除时能够正确关闭。'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s">'~'</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">'sample.txt'</span><span class="p">):</span>
        <span class="c1"># 使用读写模式打开filepath中的filename文件
</span>        <span class="bp">self</span><span class="p">.</span><span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="s">'r+'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="nb">file</span>
</pre></table></code></div></div><h2 id="ⅱ-比较操作符">Ⅱ. 比较操作符</h2><h3 id="__cmp__self-other">__cmp__(self, other)</h3><p>__cmp__ 是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（&lt;,==,!=,等等），但是它可能不能按照你需要的方式工作（例如，判断一个实例和另一个实例是否相等采用一套标准，而与判断一个实例是否大于另一实例采用另一套）。 __cmp__ 应该在 self &lt; other 时返回一个负整数，在 self == other 时返回0，在 self &gt; other 时返回正整数。最好只定义你所需要的比较形式，而不是一次定义全部。 如果你需要实现所有的比较形式，而且它们的判断标准类似，那么 __cmp__ 是一个很好的方法，可以减少代码重复，让代码更简洁。python3中被取消</p><h3 id="__eq__self-other">__eq__(self, other)</h3><p>定义等于操作符(==)的行为。</p><h3 id="__ne__self-other">__ne__(self, other)</h3><p>定义不等于操作符(!=)的行为。</p><h3 id="__lt__self-other">__lt__(self, other)</h3><p>定义小于操作符(&lt;)的行为。</p><h3 id="__gt__self-other">__gt__(self, other)</h3><p>定义大于操作符(&gt;)的行为。</p><h3 id="__le__self-other">__le__(self, other)</h3><p>定义小于等于操作符(&lt;)的行为。</p><h3 id="__ge__self-other">__ge__(self, other)</h3><p>定义大于等于操作符(&gt;)的行为。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Word</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="s">'''单词类，按照单词长度来定义比较行为'''</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="c1"># 注意，我们只能使用 __new__ ，因为str是不可变类型
</span>        <span class="c1"># 所以我们必须提前初始化它（在实例创建时）
</span>        <span class="k">if</span> <span class="s">' '</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">"Value contains spaces. Truncating to first space."</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="n">word</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="s">' '</span><span class="p">)]</span>
            <span class="c1"># Word现在包含第一个空格前的所有字母
</span>        <span class="k">return</span> <span class="nb">str</span><span class="p">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="ⅲ-一元操作符">Ⅲ. 一元操作符</h2><h3 id="__pos__self">__pos__(self)</h3><p>实现取正操作，例如 +some_object。</p><h3 id="__neg__self">__neg__(self)</h3><p>实现取负操作，例如 -some_object。</p><h3 id="__abs__self">__abs__(self)</h3><p>实现内建绝对值函数 abs() 操作。</p><h3 id="__invert__self">__invert__(self)</h3><p>实现取反操作符 ~</p><h3 id="__round__self-n">__round__(self， n)</h3><p>实现内建函数 round() ，n 是近似小数点的位数。</p><h3 id="__floor__self">__floor__(self)</h3><p>实现 math.floor() 函数，即向下取整。</p><h3 id="__ceil__self">__ceil__(self)</h3><p>实现 math.ceil() 函数，即向上取整</p><h3 id="__trunc__self">__trunc__(self)</h3><p>实现 math.trunc() 函数，即距离零最近的整数。</p><h2 id="ⅳ-算术操作符">Ⅳ. 算术操作符</h2><h3 id="__add__self-other">__add__(self, other)</h3><p>实现加法操作。</p><h3 id="__sub__self-other">__sub__(self, other)</h3><p>实现减法操作。</p><h3 id="__mul__self-other">__mul__(self, other)</h3><p>实现乘法操作。</p><h3 id="__floordiv__self-other">__floordiv__(self, other)</h3><p>实现使用 // 操作符的整数除法。</p><h3 id="__div__self-other">__div__(self, other)</h3><p>实现使用 / 操作符的除法。python3中被取消</p><h3 id="__truediv__self-other">__truediv__(self, other)</h3><p>实现 <em>true</em> 除法，这个函数只有使用 from __future__ import division 时才有作用。</p><h3 id="__mod__self-other">__mod__(self, other)</h3><p>实现 % 取余操作。</p><h3 id="__divmod__self-other">__divmod__(self, other)</h3><p>实现 divmod 内建函数。</p><h3 id="__pow__">__pow__</h3><p>实现 操作符。</p><h3 id="__lshift__self-other">__lshift__(self, other)</h3><p>实现左移位运算符 « 。</p><h3 id="__rshift__self-other">__rshift__(self, other)</h3><p>实现右移位运算符 » 。</p><h3 id="__and__self-other">__and__(self, other)</h3><p>实现按位与运算符 &amp; 。</p><h3 id="__or__self-other">__or__(self, other)</h3><p>实现按位或运算符 | 。</p><h3 id="__xor__self-other">__xor__(self, other)</h3><p>实现按位异或运算符 ^ 。</p><h2 id="ⅴ-反射算数运算符">Ⅴ. 反射算数运算符</h2><h3 id="__radd__self-other">__radd__(self, other)</h3><p>实现反射加法操作。</p><h3 id="__rsub__self-other">__rsub__(self, other)</h3><p>实现反射减法操作。</p><h3 id="__rmul__self-other">__rmul__(self, other)</h3><p>实现反射乘法操作。</p><h3 id="__rfloordiv__self-other">__rfloordiv__(self, other)</h3><p>实现使用 // 操作符的整数反射除法。</p><h3 id="__rdiv__self-other">__rdiv__(self, other)</h3><p>实现使用 / 操作符的反射除法。</p><h3 id="__rtruediv__self-other">__rtruediv__(self, other)</h3><p>实现 <em>true</em> 反射除法，这个函数只有使用 from __future__ import division 时才有作用。</p><h3 id="__rmod__self-other">__rmod__(self, other)</h3><p>实现 % 反射取余操作符。</p><h3 id="__rdivmod__self-other">__rdivmod__(self, other)</h3><p>实现调用 divmod(other, self) 时 divmod 内建函数的操作。</p><h3 id="__rpow__">__rpow__</h3><p>实现 反射操作符。</p><h3 id="__rlshift__self-other">__rlshift__(self, other)</h3><p>实现反射左移位运算符 « 的作用。</p><h3 id="__rshift__self-other-1">__rshift__(self, other)</h3><p>实现反射右移位运算符 » 的作用。</p><h3 id="__rand__self-other">__rand__(self, other)</h3><p>实现反射按位与运算符 &amp; 。</p><h3 id="__ror__self-other">__ror__(self, other)</h3><div class="table-wrapper"><table><tbody><tr><td>实现反射按位或运算符<td>。</table></div><h3 id="__rxor__self-other">__rxor__(self, other)</h3><p>实现反射按位异或运算符 ^ 。</p><h2 id="ⅵ-增强赋值运算符">Ⅵ. 增强赋值运算符</h2><h3 id="__iadd__self-other">__iadd__(self, other)</h3><p>实现加法赋值操作。</p><h3 id="__isub__self-other">__isub__(self, other)</h3><p>实现减法赋值操作。</p><h3 id="__imul__self-other">__imul__(self, other)</h3><p>实现乘法赋值操作。</p><h3 id="__ifloordiv__self-other">__ifloordiv__(self, other)</h3><p>实现使用 //= 操作符的整数除法赋值操作。</p><h3 id="__idiv__self-other">__idiv__(self, other)</h3><p>实现使用 /= 操作符的除法赋值操作。</p><h3 id="__itruediv__self-other">__itruediv__(self, other)</h3><p>实现 <em>true</em> 除法赋值操作，这个函数只有使用 from __future__ import division 时才有作用。</p><h3 id="__imod__self-other">__imod__(self, other)</h3><p>实现 %= 取余赋值操作。</p><h3 id="__ipow__">__ipow__</h3><p>实现 = 操作。</p><h3 id="__ilshift__self-other">__ilshift__(self, other)</h3><p>实现左移位赋值运算符 «= 。</p><h3 id="__irshift__self-other">__irshift__(self, other)</h3><p>实现右移位赋值运算符 »= 。</p><h3 id="__iand__self-other">__iand__(self, other)</h3><p>实现按位与运算符 &amp;= 。</p><h3 id="__ior__self-other">__ior__(self, other)</h3><div class="table-wrapper"><table><tbody><tr><td>实现按位或赋值运算符<td>。</table></div><h3 id="__ixor__self-other">__ixor__(self, other)</h3><p>实现按位异或赋值运算符 ^= 。</p><h2 id="ⅶ-类型转换操作符">Ⅶ. 类型转换操作符</h2><h3 id="__int__self">__int__(self)</h3><p>实现到int的类型转换。</p><h3 id="__long__self">__long__(self)</h3><p>实现到long的类型转换。</p><h3 id="__float__self">__float__(self)</h3><p>实现到float的类型转换。</p><h3 id="__complex__self">__complex__(self)</h3><p>实现到complex的类型转换。</p><h3 id="__oct__self">__oct__(self)</h3><p>实现到八进制数的类型转换。</p><h3 id="__hex__self">__hex__(self)</h3><p>实现到十六进制数的类型转换。</p><h3 id="__index__self">__index__(self)</h3><p>实现当对象用于切片表达式时到一个整数的类型转换。如果你定义了一个可能会用于切片操作的数值类型，你应该定义 __index__。</p><h3 id="__trunc__self-1">__trunc__(self)</h3><p>当调用 math.trunc(self) 时调用该方法， __trunc__ 应该返回 self 截取到一个整数类型（通常是long类型）的值。</p><h3 id="__coerce__self">__coerce__(self)</h3><p>该方法用于实现混合模式算数运算，如果不能进行类型转换， __coerce__ 应该返回 None 。反之，它应该返回一个二元组 self 和 other ，这两者均已被转换成相同的类型。python3中被取消</p><h2 id="ⅷ-类的表示">Ⅷ. 类的表示</h2><h3 id="__str__self">__str__(self)</h3><p>定义对类的实例调用 str() 时的行为。</p><h3 id="__repr__self">__repr__(self)</h3><p>定义对类的实例调用 repr() 时的行为。 str() 和 repr() 最主要的差别在于“目标用户”。 repr() 的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的Python代码），而 str() 则产生人类可读的输出。</p><h3 id="__unicode__self">__unicode__(self)</h3><p>定义对类的实例调用 unicode() 时的行为。 unicode() 和 str() 很像，只是它返回unicode字符串。注意，如果调用者试图调用 str() 而你的类只实现了 __unicode__() ，那么类将不能正常工作。所有你应该总是定义 __str__() ，以防有些人没有闲情雅致来使用unicode。python3中__unicode__被取消掉了</p><h3 id="__format__self">__format__(self)</h3><p>定义当类的实例用于新式字符串格式化时的行为，例如， “Hello, 0:abc!”.format(a) 会导致调用 a.__format__(“abc”) 。当定义你自己的数值类型或字符串类型时，你可能想提供某些特殊的格式化选项，这种情况下这个魔法方法会非常有用。</p><h3 id="__hash__self">__hash__(self)</h3><p>定义对类的实例调用 hash() 时的行为。它必须返回一个整数，其结果会被用于字典中键的快速比较。同时注意一点，实现这个魔法方法通常也需要实现 __eq__ ，并且遵守如下的规则： a == b 意味着 hash(a) == hash(b)。</p><h3 id="__nonzero__self">__nonzero__(self)</h3><p>定义对类的实例调用 bool() 时的行为，根据你自己对类的设计，针对不同的实例，这个魔法方法应该相应地返回True或False。python3中被重命名成__bool__</p><h3 id="__dir__self">__dir__(self)</h3><p>定义对类的实例调用 dir() 时的行为，这个方法应该向调用者返回一个属性列表。一般来说，没必要自己实现 __dir__ 。但是如果你重定义了 __getattr__ 或者 __getattribute__ （下个部分会介绍），乃至使用动态生成的属性，以实现类的交互式使用，那么这个魔法方法是必不可少的。</p><h2 id="ⅸ-访问控制">Ⅸ. 访问控制</h2><h3 id="__getattr__self-name">__getattr__(self, name)</h3><p>当用户试图访问一个根本不存在（或者暂时不存在）的属性时，你可以通过这个魔法方法来定义类的行为。这个可以用于捕捉错误的拼写并且给出指引，使用废弃属性时给出警告（如果你愿意，仍然可以计算并且返回该属性），以及灵活地处理AttributeError。只有当试图访问不存在的属性时它才会被调用，所以这不能算是一个真正的封装的办法。</p><h3 id="__setattr__self-name-value">__setattr__(self, name, value)</h3><p>和 __getattr__ 不同， __setattr__ 可以用于真正意义上的封装。它允许你自定义某个属性的赋值行为，不管这个属性存在与否，也就是说你可以对任意属性的任何变化都定义自己的规则。然后，一定要小心使用 __setattr__ ，这个列表最后的例子中会有所展示。</p><h3 id="__delattr__self-name">__delattr__(self, name)</h3><p>这个魔法方法和 __setattr__ 几乎相同，只不过它是用于处理删除属性时的行为。和 _setattr__ 一样，使用它时也需要多加小心，防止产生无限递归（在 __delattr__ 的实现中调用 del self.name 会导致无限递归）。</p><h3 id="__getattribute__self-name">__getattribute__(self, name)</h3><p>__getattribute__看起来和上面那些方法很合得来，但是最好不要使用它。 __getattribute__ 只能用于新式类。在最新版的Python中所有的类都是新式类，在老版Python中你可以通过继承 object 来创建新式类。 __getattribute__ 允许你自定义属性被访问时的行为，它也同样可能遇到无限递归问题（通过调用基类的 __getattribute__ 来避免）。 __getattribute__ 基本上可以替代 __getattr__ 。只有当它被实现，并且显式地被调用，或者产生 AttributeError 时它才被使用。 这个魔法方法可以被使用（毕竟，选择权在你自己），我不推荐你使用它，因为它的使用范围相对有限（通常我们想要在赋值时进行特殊操作，而不是取值时），而且实现这个方法很容易出现Bug。</p><p>自定义这些控制属性访问的魔法方法很容易导致问题，考虑下面这个例子:</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># 因为每次属性幅值都要调用 __setattr__()，所以这里的实现会导致递归
</span>    <span class="c1"># 这里的调用实际上是 self.__setattr('name', value)。因为这个方法一直
</span>    <span class="c1"># 在调用自己，因此递归将持续进行，直到程序崩溃
</span>
<span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># 使用 __dict__ 进行赋值
</span>    <span class="c1"># 定义自定义行为
</span></pre></table></code></div></div><p>下面的例子展示了实际应用中某些特殊的属性访问方法(注意我们之所以使用 super 是因为不是所有的类都有 <strong>dict</strong> 属性)</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">AccessCounter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">''' 一个包含了一个值并且实现了访问计数器的类
    每次值的变化都会导致计数器自增'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__setattr__</span><span class="p">(</span><span class="s">'counter'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__setattr__</span><span class="p">(</span><span class="s">'value'</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'value'</span><span class="p">:</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__setattr_</span><span class="p">(</span><span class="s">'counter'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 使计数器自增变成不可避免
</span>        <span class="c1"># 如果你想阻止其他属性的赋值行为
</span>        <span class="c1"># 产生 AttributeError(name) 就可以了
</span>        <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'value'</span><span class="p">:</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__setattr</span><span class="p">(</span><span class="s">'counter'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">AccessCounter</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__delattr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="ⅹ-自定义序列">Ⅹ. 自定义序列</h2><p>既然讲到创建自己的序列类型，就不得不说一说协议了。协议类似某些语言中的接口，里面包含的是一些必须实现的方法。在Python中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。</p><p>为什么我们要讲协议？因为在Python中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义 __len__ 和 __getitem__ (后面会具体说明）。可变容器的协议除了上面提到的两个方法之外，还需要定义 __setitem__ 和 __delitem__ 。最后，如果你想让你的对象可以迭代，你需要定义 __iter__ ，这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义 __iter__ （返回它自己）和 next 方法。</p><h3 id="__len__self">__len__(self)</h3><p>返回容器的长度，可变和不可变类型都需要实现。</p><h3 id="__getitem__self-key">__getitem__(self, key)</h3><p>定义对容器中某一项使用 self[key] 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常。</p><h3 id="__setitem__self-key">__setitem__(self, key)</h3><p>定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常。</p><h3 id="__iter__self-key">__iter__(self, key)</h3><p>它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用 iter() 函数调用，以及在类似 for x in container: 的循环中被调用。迭代器是他们自己的对象，需要定义 __iter__ 方法并在其中返回自己。</p><h3 id="__reversed__self">__reversed__(self)</h3><p>定义了对容器使用 reversed() 内建函数时的行为。它应该返回一个反转之后的序列。当你的序列类是有序时，类似列表和元组，再实现这个方法，</p><h3 id="__contains__self-item">__contains__(self, item)</h3><p>__contains__ 定义了使用 in 和 not in 进行成员测试时类的行为。你可能好奇为什么这个方法不是序列协议的一部分，原因是，如果 __contains__ 没有定义，Python就会迭代整个序列，如果找到了需要的一项就返回 True 。</p><h3 id="__missing__self-key">__missing__(self ,key)</h3><p>__missing__ 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， “george” 不是字典中的一个键，当试图访问 d[“george’] 时就会调用 d.__missing__(“george”) ）。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1"># 一个实现了一些函数式结构的列表
</span><span class="k">class</span> <span class="nc">FunctionalList</span><span class="p">:</span>
    <span class="s">'''一个列表的封装类，实现了一些额外的函数式
    方法，例如head, tail, init, last, drop和take。'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># 如果键的类型或值不合法，列表会返回异常
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得第一个元素
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得除第一个元素外的所有元素
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">valuse</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得除最后一个元素外的所有元素
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 取得最后一个元素
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># 取得除前n个元素外的所有元素
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># 取得前n个元素
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
</pre></table></code></div></div><h2 id="ⅺ-反射">Ⅺ. 反射</h2><h3 id="__instancecheck__self-instance">__instancecheck__(self, instance)</h3><p>检查一个实例是否是你定义的类的一个实例（例如 isinstance(instance, class) ）。</p><h3 id="__subclasscheck__self-subclass">__subclasscheck__(self, subclass)</h3><p>检查一个类是否是你定义的类的子类（例如 issubclass(subclass, class) ）。</p><h2 id="ⅻ-抽象基类">Ⅻ. 抽象基类</h2><h3 id="见参考文档-httpdocspythonorg2libraryabchtml">见参考文档 http://docs.python.org/2/library/abc.html</h3><h2 id="xiii-可调用的对象">XIII. 可调用的对象</h2><p>Python中一个特殊的魔法方法允许你自己类的对象表现得像是函数，然后你就可以“调用”它们，把它们传递到使用函数做参数的函数中，等等等等。这是另一个强大而且方便的特性</p><h3 id="__call__self-args">__call__(self, [args…])</h3><p>允许类的一个实例像函数那样被调用。本质上这代表了 x() 和 x.__call__() 是相同的。注意 __call__ 可以有多个参数，这代表你可以像定义其他任何函数一样，定义 __call__ ，喜欢用多少参数就用多少。</p><p>__call__ 在某些需要经常改变状态的类的实例中显得特别有用。“调用”这个实例来改变它的状态，是一种更加符合直觉，也更加优雅的方法。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Entity</span><span class="p">:</span>
        <span class="s">'''表示一个实体的类，调用它的实例
        可以更新实体的位置'''</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="s">'''改变实体的位置'''</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></table></code></div></div><h2 id="xiv-上下文管理器">XIV. 上下文管理器</h2><p>当对象使用 with 声明创建时，上下文管理器允许类做一些设置和清理工作。上下文管理器的行为由两个魔法方法所定义：</p><h3 id="__enter__self">__enter__(self)</h3><p>定义使用 with 声明创建的语句块最开始上下文管理器应该做些什么。注意 __enter__ 的返回值会赋给 with 声明的目标，也就是 as 之后的东西。</p><h3 id="__exit__self-exception_type-exception_value-traceback">__exit__(self, exception_type, exception_value, traceback)</h3><p>定义当 with 声明语句块执行完毕（或终止）时上下文管理器的行为。它可以用来处理异常，进行清理，或者做其他应该在语句块结束之后立刻执行的工作。如果语句块顺利执行， exception_type , exception_value 和 traceback 会是 None 。否则，你可以选择处理这个异常或者让用户来处理。如果你想处理异常，确保 __exit__ 在完成工作之后返回 True 。如果你不想处理异常，那就让它发生吧。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Closer</span><span class="p">:</span>
    <span class="s">'''一个上下文管理器，可以在with语句中
    使用close()自动关闭对象'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">obj</span> <span class="c1"># 绑定到目标
</span>
    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">obj</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="nb">AttributeError</span><span class="p">:</span> <span class="c1"># obj不是可关闭的
</span>                <span class="k">print</span> <span class="s">'Not closable.'</span>
                <span class="k">return</span> <span class="bp">True</span> <span class="c1"># 成功地处理了异常
</span>
            
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">magicmethods</span> <span class="kn">import</span> <span class="n">Closer</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">ftplib</span> <span class="kn">import</span> <span class="n">FTP</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">Closer</span><span class="p">(</span><span class="n">FTP</span><span class="p">(</span><span class="s">'ftp.somesite.com'</span><span class="p">))</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="p">...</span>         <span class="n">conn</span><span class="p">.</span><span class="nb">dir</span><span class="p">()</span>
<span class="p">...</span>
<span class="c1"># 为了简单，省略了某些输出
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">conn</span><span class="p">.</span><span class="nb">dir</span><span class="p">()</span>
<span class="c1"># 很长的 AttributeError 信息，不能使用一个已关闭的连接
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">Closer</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="k">as</span> <span class="n">i</span><span class="p">:</span>
<span class="p">...</span>         <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">...</span>
<span class="n">Not</span> <span class="n">closable</span><span class="p">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i</span>
<span class="mi">6</span>    
</pre></table></code></div></div><h2 id="xv-创建描述符对象">XV. 创建描述符对象</h2><p>描述符是一个类，当使用取值，赋值和删除 时它可以改变其他对象。描述符不是用来单独使用的，它们需要被一个拥有者类所包含。描述符可以用来创建面向对象数据库，以及创建某些属性之间互相依赖的类。描述符在表现具有不同单位的属性，或者需要计算的属性时显得特别有用（例如表现一个坐标系中的点的类，其中的距离原点的距离这种属性）。</p><p>要想成为一个描述符，一个类必须具有实现 __get__ , __set__ 和 __delete__ 三个方法中至少一个。</p><h3 id="__get__self-instance-owner">__get__(self, instance, owner)</h3><p>定义当试图取出描述符的值时的行为。 instance 是拥有者类的实例， owner 是拥有者类本身。</p><h3 id="__set__self-instance-owner">__set__(self, instance, owner)</h3><p>定义当描述符的值改变时的行为。 instance 是拥有者类的实例， value 是要赋给描述符的值。</p><h3 id="__delete__self-instance-owner">__delete__(self, instance, owner)</h3><p>定义当描述符的值被删除时的行为。 instance 是拥有者类的实例</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Meter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">'''米的描述符。'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">'''英尺的描述符。'''</span>

    <span class="k">def</span> <span class="nf">__get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">instance</span><span class="p">.</span><span class="n">meter</span> <span class="o">*</span> <span class="mf">3.2808</span>
    <span class="k">def</span> <span class="nf">__set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">instance</span><span class="p">.</span><span class="n">meter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.2808</span>

<span class="k">class</span> <span class="nc">Distance</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">'''用于描述距离的类，包含英尺和米两个描述符。'''</span>
    <span class="n">meter</span> <span class="o">=</span> <span class="n">Meter</span><span class="p">()</span>
    <span class="n">foot</span> <span class="o">=</span> <span class="n">Foot</span><span class="p">()</span>
</pre></table></code></div></div><h2 id="xvi-拷贝">XVI. 拷贝</h2><p>有些时候，特别是处理可变对象时，你可能想拷贝一个对象，改变这个对象而不影响原有的对象。这时就需要用到Python的 copy 模块了。然而（幸运的是），Python模块并不具有感知能力， 因此我们不用担心某天基于Linux的机器人崛起。但是我们的确需要告诉Python如何有效率地拷贝对象。</p><h3 id="__copy__self">__copy__(self)</h3><p>定义对类的实例使用 copy.copy() 时的行为。 copy.copy() 返回一个对象的浅拷贝，这意味着拷贝出的实例是全新的，然而里面的数据全都是引用的。也就是说，对象本身是拷贝的，但是它的数据还是引用的（所以浅拷贝中的数据更改会影响原对象）。</p><h3 id="__deepcopy__self-memodict">__deepcopy__(self, memodict=)</h3><p>定义对类的实例使用 copy.deepcopy() 时的行为。 copy.deepcopy() 返回一个对象的深拷贝，这个对象和它的数据全都被拷贝了一份。 memodict 是一个先前拷贝对象的缓存，它优化了拷贝过程，而且可以防止拷贝递归数据结构时产生无限递归。当你想深拷贝一个单独的属性时，在那个属性上调用 copy.deepcopy() ，使用 memodict 作为第一个参数。</p><h2 id="xvii-pickling">XVII. Pickling</h2><p>Pickling是Python数据结构的序列化过程，当你想存储一个对象稍后再取出读取时，Pickling会显得十分有用。然而它同样也是担忧和混淆的主要来源。</p><p>Pickling是如此的重要，以至于它不仅仅有自己的模块（ pickle ），还有自己的协议和魔法方法。</p><p>Pickle不仅仅可以用于内建类型，任何遵守pickle协议的类都可以被pickle。Pickle协议有四个可选方法，可以让类自定义它们的行为</p><h3 id="__getinitargs__self">__getinitargs__(self)</h3><p>如果你想让你的类在反pickle时调用 __init__ ，你可以定义 __getinitargs__(self) ，它会返回一个参数元组，这个元组会传递给 __init__ 。注意，这个方法只能用于旧式类。</p><h3 id="__getnewargs__self">__getnewargs__(self)</h3><p>对新式类来说，你可以通过这个方法改变类在反pickle时传递给 __new__ 的参数。这个方法应该返回一个参数元组。</p><h3 id="__getstate__self">__getstate__(self)</h3><p>你可以自定义对象被pickle时被存储的状态，而不使用对象的 __dict__ 属性。 这个状态在对象被反pickle时会被 __setstate__ 使用。</p><h3 id="__setstate__self">__setstate__(self)</h3><p>当一个对象被反pickle时，如果定义了 __setstate__ ，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 __dict__ 属性。这个魔法方法和 __getstate__ 相互依存：当这两个方法都被定义时，你可以在Pickle时使用任何方法保存对象的任何状态。</p><h3 id="__reduce__self">__reduce__(self)</h3><p>当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 __reduce__ 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 __setstate__ 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；</p><h3 id="__reduce_ex__self">__reduce_ex__(self)</h3><p>__reduce_ex__ 的存在是为了兼容性。如果它被定义，在pickle时 __reduce_ex__ 会代替 __reduce__ 被调用。 __reduce__ 也可以被定义，用于不支持 __reduce_ex__ 的旧版pickle的API调用。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Slate</span><span class="p">:</span>
        <span class="s">'''存储一个字符串和一个变更日志的类
        每次被pickle都会忘记它当前的值'''</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">last_change</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">asctime</span><span class="p">()</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">history</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
                <span class="c1"># 改变当前值，将上一个值记录到历史
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">history</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">last_change</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">last_change</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">asctime</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">print_change</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">'Changelog for Slate object:'</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">history</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">print</span> <span class="s">'%s</span><span class="se">\t</span><span class="s"> %s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># 故意不返回self.value或self.last_change
</span>                <span class="c1"># 我们想在反pickle时得到一个空白的slate
</span>                <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">history</span>

        <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># 使self.history = slate，last_change
</span>                <span class="c1"># 和value为未定义
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">state</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">last_change</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
</pre></table></code></div></div><h2 id="附录1-如何调用魔法方法">附录1. 如何调用魔法方法</h2><p>一些魔法方法直接和内建函数对应，这种情况下，如何调用它们是显而易见的。然而，另外的情况下，调用魔法方法的途径并不是那么明显。这个附录旨在展示那些不那么明显的调用魔法方法的语法。</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">魔法方法<th style="text-align: left">什么时候被调用<th>解释<tbody><tr><td style="text-align: left">__new__(cls [,…])<td style="text-align: left">instance = MyClass(arg1, arg2)<td>__new__在实例创建时调用<tr><td style="text-align: left">__init__(self [,…])<td style="text-align: left">instance = MyClass(arg1,arg2)<td>__init__在实例创建时调用<tr><td style="text-align: left">__cmp__(self)<td style="text-align: left">self == other, self &gt; other 等<td>进行比较时调用<tr><td style="text-align: left">__pos__(self)<td style="text-align: left">+self<td>一元加法符号<tr><td style="text-align: left">__neg__(self)<td style="text-align: left">-self<td>一元减法符号<tr><td style="text-align: left">__invert__(self)<td style="text-align: left">~self<td>按位取反<tr><td style="text-align: left">__index__(self)<td style="text-align: left">x[self]<td>当对象用于索引时<tr><td style="text-align: left">__nonzero__(self)<td style="text-align: left">bool(self)<td>对象的布尔值<tr><td style="text-align: left">__getattr__(self, name)<td style="text-align: left">self.name #name不存在<td>访问不存在的属性<tr><td style="text-align: left">__setattr__(self, name)<td style="text-align: left">self.name = val<td>给属性赋值<tr><td style="text-align: left">__delattr_(self, name)<td style="text-align: left">del self.name<td>删除属性<tr><td style="text-align: left">__getattribute__(self,name)<td style="text-align: left">self.name<td>访问任意属性<tr><td style="text-align: left">__getitem__(self, key)<td style="text-align: left">self[key]<td>使用索引访问某个元素<tr><td style="text-align: left">__setitem__(self, key)<td style="text-align: left">self[key] = val<td>使用索引给某个元素赋值<tr><td style="text-align: left">__delitem__(self, key)<td style="text-align: left">del self[key]<td>使用索引删除某个对象<tr><td style="text-align: left">__iter__(self)<td style="text-align: left">for x in self<td>迭代<tr><td style="text-align: left">__contains__(self, value)<td style="text-align: left">value in self, value not in self<td>使用in进行成员测试<tr><td style="text-align: left">__call__(self [,…])<td style="text-align: left">self(args)<td>“调用”一个实例<tr><td style="text-align: left">__enter__(self)<td style="text-align: left">with self as x:<td>with声明的上下文管理器<tr><td style="text-align: left">__exit__(self, exc, val, trace)<td style="text-align: left">with self as x:<td>with声明的上下文管理器<tr><td style="text-align: left">__getstate__(self)<td style="text-align: left">pickle.dump(pkl_file, self)<td>Pickling<tr><td style="text-align: left">__setstate__(self)<td style="text-align: left">data = pickle.load(pkl_file)<td>Pickling</table></div><h2 id="附录2-python-3中的变化">附录2. Python 3中的变化</h2><p>在这里，我们记录了几个在对象模型方面 Python 3 和 Python 2.x 之间的主要区别。</p><p>◆ Python 3中string和unicode的区别不复存在，因此 __unicode__ 被取消了， __bytes__ 加入进来（与Python 2.7 中的 __str__ 和 __unicode__ 行为类似），用于新的创建字节数组的内建方法。</p><p>◆ Python 3中默认除法变成了 true 除法，因此 __div__ 被取消了。</p><p>◆ __coerce__ 被取消了，因为和其他魔法方法有功能上的重复，以及本身行为令人迷惑。</p><p>◆ __cmp__ 被取消了，因为和其他魔法方法有功能上的重复。</p><p>◆ __nonzero__ 被重命名成 __bool__ 。</p><p>整理并转自:https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/python/'>Python</a>, <a href='/categories/python%E8%BF%9B%E9%98%B6/'>Python进阶</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/python%E8%BF%9B%E9%98%B6/" class="post-tag no-text-decoration" >Python进阶</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Python 魔法方法 指南 - 图样图森破&url=https://justzxy.cn/posts/python-magic/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Python 魔法方法 指南 - 图样图森破&u=https://justzxy.cn/posts/python-magic/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Python 魔法方法 指南 - 图样图森破&url=https://justzxy.cn/posts/python-magic/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/js/">JavaScript基础整理</a><li><a href="/posts/http-code/">HTTP 响应码</a><li><a href="/posts/pip/">python包管理工具pip</a><li><a href="/posts/pyecharts-pie/">pyecharts饼图使用笔记</a><li><a href="/posts/redis-fast/">Redis为什么这么快</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python%E6%A0%87%E5%87%86%E5%BA%93/">Python标准库</a> <a class="post-tag" href="/tags/web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">Web开发技术</a> <a class="post-tag" href="/tags/python%E8%BF%9B%E9%98%B6/">Python进阶</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> <a class="post-tag" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E7%A1%80/">Python基础</a> <a class="post-tag" href="/tags/redis/">Redis</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/with-context/"><div class="card-body"> <span class="timeago small" > Apr 30, 2018 <i class="unloaded">2018-04-30T19:48:26+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>with语句和上下文管理器</h3><div class="text-muted small"><p> 任何实现了 __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。__enter__() 方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__() 方法处理一些清除工作。 class File(): def __init__(self, filename, mode): se...</p></div></div></a></div><div class="card"> <a href="/posts/iterable-iterator/"><div class="card-body"> <span class="timeago small" > May 5, 2018 <i class="unloaded">2018-05-05T20:23:49+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>迭代器和生成器</h3><div class="text-muted small"><p> 迭代器 可以直接作用于for循环的对象统称为可迭代对象：Iterable 可以使用isinstance()判断一个对象是否是Iterable对象 In [50]: from collections import Iterable In [51]: isinstance([], Iterable) Out[51]: True In [55]: isinstance(100, ...</p></div></div></a></div><div class="card"> <a href="/posts/copy-reference/"><div class="card-body"> <span class="timeago small" > Sep 9, 2018 <i class="unloaded">2018-09-09T18:57:42+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Python中的赋值_引用_拷贝_传参</h3><div class="text-muted small"><p> 1.赋值 VS 引用 我们都知道Python的赋值运算符是“=”，如： &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = a &gt;&gt;&gt; b &gt;&gt;&gt; 1 &gt;&gt;&gt; id(a) &gt;&gt;&gt; 10432856 &gt;&gt;&gt; id(b) &gt;&gt;&gt; 10432856 id函数可以获...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/logging/" class="btn btn-outline-primary" prompt="Older"><p>logging日志模块</p></a> <a href="/posts/csrf-cors/" class="btn btn-outline-primary" prompt="Newer"><p>CSRF与CORS</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 tooYoungtooSimple. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python%E6%A0%87%E5%87%86%E5%BA%93/">Python标准库</a> <a class="post-tag" href="/tags/web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">Web开发技术</a> <a class="post-tag" href="/tags/python%E8%BF%9B%E9%98%B6/">Python进阶</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> <a class="post-tag" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E7%A1%80/">Python基础</a> <a class="post-tag" href="/tags/redis/">Redis</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://justzxy.cn{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
