<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Python中的赋值_引用_拷贝_传参" /><meta property="og:locale" content="en_US" /><meta name="description" content="1.赋值 VS 引用" /><meta property="og:description" content="1.赋值 VS 引用" /><link rel="canonical" href="https://justzxy.cn/posts/copy-reference/" /><meta property="og:url" content="https://justzxy.cn/posts/copy-reference/" /><meta property="og:site_name" content="图样图森破" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-09-09T18:57:42+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Python中的赋值_引用_拷贝_传参" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"1.赋值 VS 引用","url":"https://justzxy.cn/posts/copy-reference/","headline":"Python中的赋值_引用_拷贝_传参","dateModified":"2021-07-19T23:50:50+08:00","datePublished":"2018-09-09T18:57:42+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://justzxy.cn/posts/copy-reference/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Python中的赋值_引用_拷贝_传参 | 图样图森破</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="图样图森破"><meta name="application-name" content="图样图森破"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">图样图森破</a></div><div class="site-subtitle font-italic">Too Young Too Simple</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Python中的赋值_引用_拷贝_传参</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Python中的赋值_引用_拷贝_传参</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tooYoungtooSimple </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Sep 9, 2018, 6:57 PM +0800" prep="on" > Sep 9, 2018 <i class="unloaded">2018-09-09T18:57:42+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jul 19, 2021, 11:50 PM +0800" prefix="Updated " > Jul 19 <i class="unloaded">2021-07-19T23:50:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4099 words">22 min</span></div></div><div class="post-content"><h2 id="1赋值-vs-引用">1.赋值 VS 引用</h2><p>我们都知道Python的赋值运算符是“=”，如：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">10432856</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">10432856</span>
</pre></table></code></div></div><p>id函数可以获得对象的内存地址。很明显从上面例子可以看出，将a变量作为参数赋值给了b变量，传递了a的一个引用，把a的地址传递过去了，所以变量b的地址跟变量a的地址是一样的。</p><p>下面我们看第一个案例:</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779781384</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779781384</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779781384</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779781384</span>
</pre></table></code></div></div><p>将一个可变类型的对象–列表[1, 2]赋值给变量c,再将变量c赋值给变量d，传递了c的引用，c和d同时指向一个内存地址，通过d把内存地址的对象[1, 2]变为[1, 2, 3]，变量c的值也相应改变了。</p><p>所以，<strong>在 Python中赋值语句总是建立对象的引用值，而不是复制对象</strong>。因此，<strong>Python 变量更像是指针，而不是数据存储区域</strong>。</p><h2 id="2引用-vs-拷贝">2.引用 VS 拷贝</h2><p>先来看下面这个案例:</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779905776</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">values</span>
</pre></table></code></div></div><p>吃过之前的亏之后，我们自然而然的会认为 values 会变成 [0, [0, 1, 2], 2] ，然而结果如下：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">values</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[...],</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779905776</span>
</pre></table></code></div></div><p>结果赋值无限次？</p><p>之前我们已经说过，<strong>Python 没有赋值，只有引用</strong>。“ L[1] = L ” 相当于创建了一个引用自身的结构，所以导致了无限循环。为了理解这个问题，有个基本概念需要搞清楚。</p><p><strong>Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用。</strong></p><p>执行 “values = [0, 1, 2]” 的时候，Python 做的事情是首先创建一个列表对象 [0, 1, 2]，然后给它贴上名为 values 的标签。如果随后又执行 “values = [3, 4, 5]” 的话，Python 做的事情是创建另一个列表对象 [3, 4, 5]，然后把刚才那张名为 values 的标签从前面的 [0, 1, 2] 对象上撕下来，重新贴到 [3, 4, 5] 这个对象上。</p><p>至始至终，并没有一个叫做 values 的列表对象容器存在，Python 也没有把任何对象的值复制进 values 去。过程如下图所示：</p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用1.jpg" alt="" /></p><p>执行 “values[1] = values” 的时候，Python 做的事情则是把 values 这个标签所引用的列表对象的第二个元素指向 values 所引用的列表对象本身。执行完毕后，values 标签还是指向原来那个对象，只不过那个对象的结构发生了变化，从之前的列表 [0, 1, 2] 变成了 [0, ?, 2]，而这个 ? 则是指向那个对象本身的一个引用。如下图所示：</p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用2.jpg" alt="" /></p><p>要达到我们之前所期望的的效果，即得到 [0, [0, 1, 2], 2] 这个对象，我们不能直接将 values[1] 指向 values 引用的对象本身，而是需要吧 [0, 1, 2] 这个对象「复制」一遍，得到一个新对象，再将 values[1] 指向这个复制后的对象。Python 里面复制对象的操作因对象类型而异，复制列表 values 的操作是values[:] （生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制）</p><p>所以我们需要执行如下操作：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779951256</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">values</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">140594779951256</span>
</pre></table></code></div></div><p>Python 做的事情是，先 通过引用得到 values 所指向的对象[0, 1, 2]，然后执行 [0, 1, 2][:] 复制操作得到一个新的对象，内容也是 [0, 1, 2]，然后将 values 所指向的列表对象的第二个元素指向这个复制而来的列表对象，最终 values 指向的对象是 [0, [0, 1, 2], 2]。过程如下图所示：</p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用3.jpg" alt="" /></p><p>但是，当列表对象有嵌套的时候会产生新的问题，比如：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></table></code></div></div><p>此时 a 和 b 分别是多少？</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">]</span>
</pre></table></code></div></div><p>b 的第二个元素也被改变了！</p><p>其实，往更深处说，values[:] 复制操作是所谓的「<strong>浅拷贝</strong>」(shallow copy)，过程如下图所示：</p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用4.jpg" alt="" /></p><p>正确的复制嵌套元素的方法是进行「<strong>深拷贝</strong>」(deep copy)，方法是：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">copy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">]</span>
</pre></table></code></div></div><p><strong>结论</strong></p><ol><li><p>没有限制条件的切片表达式（ L[:] ）能够复制序列，但此法只能浅拷贝；</p><li><p>有些内置函数，例如 list，能够生成拷贝 list(L)；</p><li><p>copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy ；</p><li><p>与列表相同，字典也有 copy 方法，Dict.copy() 为浅拷贝，copy.deepcopy( Dict )则是深拷贝；</p></ol><p>对于不可变对象和可变对象来说，浅拷贝都是复制的引用，只是因为复制不变对象和复制不变对象的引用是等效的（因为对象不可变，当改变时会新建对象重新赋值）。所以看起来浅拷贝只复制不可变对象（整数，实数，字符串等），对于可变对象，浅拷贝其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了另一个标签而已。</p><h2 id="3赋值-vs-增强赋值">3.赋值 VS 增强赋值</h2><p>我们来看下面的案例：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></table></code></div></div><p><strong>赋值语句 x = x + y，会新建对象 x，然后复制两个列表合并，属于复制/拷贝；</strong></p><p><strong>增强赋值语句 x += y，不生成新对象，只在内存块末尾增加元素。</strong></p><p>当 x、y 为list时， += 会自动调用 extend 方法进行合并运算，属于共享引用。</p><h2 id="4参数传递">4.参数传递</h2><p>函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：<strong>值传递</strong>和<strong>引用传递</strong>。</p><p><strong>值传递</strong>（pass-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。</p><p><strong>引用传递</strong>(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><p>在python中实际又是怎么样的呢？</p><h3 id="41可变类型-vs-不可变类型">4.1可变类型 VS 不可变类型</h3><p>在Python中，对象分为两种：可变类型和不可变类型，不可变类型的对象包括int，float，long，str，tuple等，可变类型的对象包括list，set，dict等。需要注意的是：这里说的不可变指的是值的不可变。对于不可变类型的变量，如果要更改变量，则会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收。另外，不可变的类型可以计算hash值，作为字典的key。可变类型数据对对象操作的时候，不需要再在其它地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func_int</span><span class="p">(</span><span class="n">a_int</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">a_int</span> <span class="o">+=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func_list</span><span class="p">(</span><span class="n">a_list</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">a_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">b_int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">func_int</span><span class="p">(</span><span class="n">b_int</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b_int</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">func_list</span><span class="p">(</span><span class="n">b_list</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b_list</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></table></code></div></div><p>对于上面的输出，不少Python初学者都比较疑惑：第一个例子看起来像是传值，而第二个例子却是传引用。其实，解释这个问题也非常容易，主要是因为可变类型参数和不可变类型参数的原因：对于可变类型参数，对象的操作不会重建对象，而对于不可变类型参数，每一次操作就重建新的对象。</p><p>在函数参数传递的时候，Python其实就是把参数里传入的变量对应的对象的引用依次赋值给对应的函数内部变量。参照上面的例子来说明更容易理解，func_int 中的局部变量 “a_int” 其实是全局变量 “b_int” 所指向对象的另一个引用，由于整数对象是不可变的，所以当 func_int 对变量 “a_int” 进行修改的时候，实际上是将局部变量 “a_int” 指向到了整数对象 “4” 。所以很明显，func_list 修改的是一个可变的对象，局部变量 “a_list” 和全局变量 “b_list” 指向的还是同一个对象。</p><h3 id="42局部变量-vs-全局变量">4.2局部变量 VS 全局变量</h3><p>我们先来看下面这个例子：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s">'abc'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">a</span> <span class="o">=</span> <span class="s">'def'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">func</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">'abc'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></table></code></div></div><p>我们知道变量 “a” 没有改变是因为 “a” 在函数中是局部变量，如果要修改全局变量 “a” 需要用到关键字 ”global“ ，为什么修改字列表 ”b“ 的值不用global关键字先声明呢？</p><p>这是因为，在 a = ‘def’ 这句中，它是“有歧义的“，因为它既可以是表示引用全局变量 ”a” ，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global，global定义的本地变量会变成其对应全局变量的一个别名，即是同一个变量。</p><p>在 b[0] = 4 这句中，它是“明确的”，因为如果把 “b” 当作是局部变量的话，它会报KeyError，所以它只能是引用全局的 “b” ,故不需要多此一举显式声明global。</p><p>但如果是下面：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func2</span><span class="p">():</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">func2</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></table></code></div></div><p>在 c = [3, 4] 这句，它是”有歧义的“了，所以它是创建了局部变量 “c” ，而不是引用全局变量 “c” ，所以 c[0] = 5 也是操作的局部变量。</p><p>推而远之，这一切现象的本质就是“它是否是明确的”。</p><p>仔细想想，就会发现不止 list 不需要global，所有”明确的“东西都不需要global。因为int、str之类的不可变类型，每一次操作就重建新的对象，他们只有一种修改方法，即 x = y ， 恰好这种修改方法同时也是创建变量的方法，所以产生了歧义，不知道是要修改还是创建。而dict、list等可变类型，操作不会重建对象，可以通过 list.append() 或 dict[‘x’]=y 之类的来修改，跟创建变量不冲突，不产生歧义，所以都不用显式global。</p><h3 id="43----vs--appendextend">4.3“ = ” VS append/extend</h3><p>先看如下案例：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">list_a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">list_a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list_a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">list_b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="n">list_b</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list_b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></table></code></div></div><p>为什么 a() 不能改变 list_a 的值，而 语句 b() 却可以？他们的差别在哪呢？</p><p>因为 “=” 创建了局部变量，而 .append() 或者 .extend() 重用了全局变量。</p><h3 id="44默认参数的陷阱">4.4默认参数的陷阱</h3><p>讲到参数传递就不得不提默认参数的陷阱：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="p">[]):</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="nb">list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="k">return</span> <span class="nb">list</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="err">’</span><span class="n">a</span><span class="err">‘</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list3</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="s">'b'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list3</span>
</pre></table></code></div></div><p>这些代码将会输出什么？</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="p">[]):</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="nb">list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="k">return</span> <span class="nb">list</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list3</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="s">'b'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">'b'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'a'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">'b'</span><span class="p">]</span>
</pre></table></code></div></div><p>许多人会错误的认为 list1 应该等于 [1] 以及 list3 应该等于 [‘b’]。认为 list 的参数会在 func 每次被调用的时候会被设置成它的默认值 []。</p><p>实际发生的事情是，新的默认列表仅仅只在函数被定义时创建一次。随后当 func 没有被指定的列表参数调用的时候，其使用的是同一个列表。这就是为什么当函数被定义的时候，表达式是用默认参数被计算，而不是它被调用的时候。</p><p>因此，list1 和 list3 是操作的相同的列表。而 list2 操作的是被传入的独立的列表。</p><p>为了到达我们原先的预期，func 函数的定义可以做如下修改：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="k">if</span> <span class="nb">list</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>             <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="nb">list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>     <span class="k">return</span> <span class="nb">list</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list3</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="s">'b'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'a'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="s">'b'</span><span class="p">]</span>
</pre></table></code></div></div><p>上面的陷阱告诉我们：一定要谨慎使用可变类型的默认参数。</p><h2 id="5浅拷贝-vs-深拷贝">5.浅拷贝 VS 深拷贝</h2><h3 id="51-浅拷贝">5.1 浅拷贝</h3><ul><li>浅拷贝是对于一个对象的顶层拷贝. 通俗的理解是：拷贝了引用，并没有拷贝内容</ul><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用5.png" alt="" /></p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用6.png" alt="" /></p><h3 id="52-深拷贝">5.2 深拷贝</h3><ul><li>深拷贝是对于一个对象所有层次的拷贝(递归)</ul><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用7.png" alt="" /></p><p>进一步理解深拷贝</p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用8.png" alt="" /></p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用9.png" alt="" /></p><h3 id="53-拷贝的其他方式">5.3 拷贝的其他方式</h3><ul><li>分片表达式可以赋值一个序列</ul><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用10.png" alt="" /></p><ul><li>字典的copy方法可以拷贝一个字典</ul><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用11.png" alt="" /></p><h3 id="54-注意点">5.4 注意点</h3><p><strong>浅拷贝对不可变类型和可变类型的copy不同</strong></p><ol><li>copy.copy对于可变类型，会进行浅拷贝<li>copy.copy对于不可变类型，不会拷贝，仅仅是指向</ol><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">In</span> <span class="p">[</span><span class="mi">88</span><span class="p">]:</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">33</span><span class="p">]</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">89</span><span class="p">]:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">90</span><span class="p">]:</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">90</span><span class="p">]:</span> <span class="mi">59275144</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">91</span><span class="p">]:</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">91</span><span class="p">]:</span> <span class="mi">59525600</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">92</span><span class="p">]:</span> <span class="n">a</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">93</span><span class="p">]:</span> <span class="n">a</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">93</span><span class="p">]:</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">]</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">94</span><span class="p">]:</span> <span class="n">b</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">94</span><span class="p">]:</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">]</span>


<span class="n">In</span> <span class="p">[</span><span class="mi">95</span><span class="p">]:</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">33</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">96</span><span class="p">]:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">97</span><span class="p">]:</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">97</span><span class="p">]:</span> <span class="mi">58890680</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">98</span><span class="p">]:</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">98</span><span class="p">]:</span> <span class="mi">58890680</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用12.png" alt="" /></p><p><strong>copy.copy和copy.deepcopy的区别</strong></p><blockquote><p>copy.copy</p></blockquote><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用13.png" alt="" /></p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用14.png" alt="" /></p><blockquote><p>copy.deepcopy</p></blockquote><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用15.png" alt="" /></p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用16.png" alt="" /></p><p><img data-proofer-ignore data-src="/refer/赋值拷贝引用17.png" alt="" /></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/python/'>Python</a>, <a href='/categories/python%E8%BF%9B%E9%98%B6/'>Python进阶</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/python%E8%BF%9B%E9%98%B6/" class="post-tag no-text-decoration" >Python进阶</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Python中的赋值_引用_拷贝_传参 - 图样图森破&url=https://justzxy.cn/posts/copy-reference/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Python中的赋值_引用_拷贝_传参 - 图样图森破&u=https://justzxy.cn/posts/copy-reference/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Python中的赋值_引用_拷贝_传参 - 图样图森破&url=https://justzxy.cn/posts/copy-reference/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/js/">JavaScript基础整理</a><li><a href="/posts/http-code/">HTTP 响应码</a><li><a href="/posts/pip/">python包管理工具pip</a><li><a href="/posts/pyecharts-pie/">pyecharts饼图使用笔记</a><li><a href="/posts/redis-fast/">Redis为什么这么快</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python%E6%A0%87%E5%87%86%E5%BA%93/">Python标准库</a> <a class="post-tag" href="/tags/web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">Web开发技术</a> <a class="post-tag" href="/tags/python%E8%BF%9B%E9%98%B6/">Python进阶</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> <a class="post-tag" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E7%A1%80/">Python基础</a> <a class="post-tag" href="/tags/redis/">Redis</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/with-context/"><div class="card-body"> <span class="timeago small" > Apr 30, 2018 <i class="unloaded">2018-04-30T19:48:26+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>with语句和上下文管理器</h3><div class="text-muted small"><p> 任何实现了 __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。__enter__() 方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__() 方法处理一些清除工作。 class File(): def __init__(self, filename, mode): se...</p></div></div></a></div><div class="card"> <a href="/posts/iterable-iterator/"><div class="card-body"> <span class="timeago small" > May 5, 2018 <i class="unloaded">2018-05-05T20:23:49+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>迭代器和生成器</h3><div class="text-muted small"><p> 迭代器 可以直接作用于for循环的对象统称为可迭代对象：Iterable 可以使用isinstance()判断一个对象是否是Iterable对象 In [50]: from collections import Iterable In [51]: isinstance([], Iterable) Out[51]: True In [55]: isinstance(100, ...</p></div></div></a></div><div class="card"> <a href="/posts/name-space/"><div class="card-body"> <span class="timeago small" > Dec 1, 2018 <i class="unloaded">2018-12-01T23:37:41+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>命名空间和作用域</h3><div class="text-muted small"><p> 三种命名空间 内置名称（built-in names），Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。 全局名称(global names),模块中定义的名称，记录了模块的变量,包括函数、类、其它导入的模块、模块级的变量和常量。 局部名称(local names),函数中定义的名称，记录了函数的变量，包括函...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/json-module/" class="btn btn-outline-primary" prompt="Older"><p>Json模块</p></a> <a href="/posts/built-in-function/" class="btn btn-outline-primary" prompt="Newer"><p>python3内置函数</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 tooYoungtooSimple. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python%E6%A0%87%E5%87%86%E5%BA%93/">Python标准库</a> <a class="post-tag" href="/tags/web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">Web开发技术</a> <a class="post-tag" href="/tags/python%E8%BF%9B%E9%98%B6/">Python进阶</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> <a class="post-tag" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E7%A1%80/">Python基础</a> <a class="post-tag" href="/tags/redis/">Redis</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://justzxy.cn{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
