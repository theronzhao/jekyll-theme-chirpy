<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Python笔记" /><meta property="og:locale" content="en_US" /><meta name="description" content="列表 List" /><meta property="og:description" content="列表 List" /><link rel="canonical" href="https://justzxy.cn/posts/python-base/" /><meta property="og:url" content="https://justzxy.cn/posts/python-base/" /><meta property="og:site_name" content="图样图森破" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-02-15T23:37:41+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Python笔记" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"列表 List","url":"https://justzxy.cn/posts/python-base/","headline":"Python笔记","dateModified":"2019-02-15T23:37:41+08:00","datePublished":"2019-02-15T23:37:41+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://justzxy.cn/posts/python-base/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Python笔记 | 图样图森破</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="图样图森破"><meta name="application-name" content="图样图森破"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">图样图森破</a></div><div class="site-subtitle font-italic">Too Young Too Simple</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Python笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Python笔记</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tooYoungtooSimple </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Feb 15, 2019, 11:37 PM +0800" prep="on" > Feb 15, 2019 <i class="unloaded">2019-02-15T23:37:41+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="22206 words">123 min</span></div></div><div class="post-content"><h1 id="列表-list">列表 List</h1><p>aList.append(obj)<br /> 在列表末尾追加元素，等同于 aList[len(aList）:len(aList)] = [obj]</p><p>aList.clear()<br /> 删除 aList 的所有元素</p><p>aList.count(obj)<br /> 返回 aList 中与 obj 相等的元素个数</p><p>aList.copy()<br /> 返回 aList 的副本。请注意，这是浅复制，即不会复制元素</p><p>aList.extend(sequence)<br /> 将sequence中的元素逐个追加到列表当中，等同于 aList[len(aList):len(aList)] = sequence</p><p>aList.index(obj)<br /> 返回 aList 中第一个与 obj 相等的元素的索引；如果没有这样的元素，就引发ValueError 异常</p><p>aList.insert(index, obj)<br /> 如果 index &gt;= 0 ，就等同于 aList[index:index] = [obj] ；如果 index &lt; 0 ，就将指定的对象加入到列表尾端索引前一位</p><p>aList.pop([index])<br /> 删除并返回指定索引（默认为-1）处的元素</p><p>aLiast.remove(obj)<br /> 等同于 del aList[aList.index(obj)], 删除第一个与 obj 相等的元素,如果没有则引发ValueError异常</p><p>aList.reverse()<br /> 就地按相反的顺序排列列表的元素</p><p>aList.sort([key，[,reverse]）<br /> 就地对 aList 的元素进行排序（稳定排序）。可通过提供键函数key （创建用户排序的键）和降序标志 reverse （一个布尔值）进行定制.<em>key</em> 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 <code class="language-plaintext highlighter-rouge">key=str.lower</code>)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 <code class="language-plaintext highlighter-rouge">None</code> 表示直接对列表项排序而不计算一个单独的键值。</p><p><strong>列表推导式</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">freshfruit</span> <span class="o">=</span> <span class="p">[</span><span class="s">'  banana'</span><span class="p">,</span> <span class="s">'  loganberry '</span><span class="p">,</span> <span class="s">'passion fruit  '</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">weapon</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">weapon</span> <span class="ow">in</span> <span class="n">freshfruit</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</pre></table></code></div></div><h1 id="集合-set">集合 Set</h1><p>aSet.add(x)<br /> 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。x是单一元素</p><p>aSet.update(seq)<br /> 添加 seq 中的每一个元素到集合中，参数可以是列表，元组，字典等序列</p><p>aSet.remove( x )<br /> 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p><p>aSet.discard( x )<br /> 移除集合中的元素，且如果元素不存在，不会发生错误。</p><p>aSet.pop（）</p><p>随机删除集合中的一个元素并返回</p><p>aSet.clear()<br /> 清空集合中的元素</p><p>aSet.copy()<br /> 复制集合</p><p>aSet.union(set1, set2…)<br /> 返回两个集合的并集，即包含了所有集合的元素，重复的元素只会出现一次。原集合未改变</p><p>aSet.difference(bset)<br /> 返回集合的差集，即返回的集合元素包含在第一个集合中，但不包含在第二个集合(方法的参数)中</p><p>aSet.difference_update(set)<br /> 用于移除a中两个集合都存在的元素。difference_update() 方法与 difference() 方法的区别在于 difference() 方法返回一个移除相同元素的新集合，而 difference_update() 方法是直接在原来的集合中移除元素，没有返回值。</p><p>aSet.intersection(set1, set2 … etc)<br /> 返回两个或更多集合中都包含的元素，即交集。</p><p>aSet.intersection_update(set1, set2 … etc)<br /> 用于获取两个或更多集合中都重叠的元素，即计算交集.intersection_update() 方法不同于 intersection() 方法，因为 intersection() 方法是返回一个新的集合，而 intersection_update() 方法是在原始的集合上移除不重叠的元素。</p><p>aSet.isdisjoint(set)<br /> 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</p><p>aSet.issubset(set)<br /> 判断集合的所有元素是否都包含在指定集合中，如果是则返回 True，否则返回 False。</p><p>aSet.issuperset(set)<br /> 判断指定集合的所有元素是否都包含在原始的集合中，如果是则返回 True，否则返回 False。</p><p>aSet.symmetric_difference(set)<br /> 返回两个集合中不重复的元素集合，即会移除两个集合中都存在的元素。</p><p>aSet.symmetric_difference_update(set)<br /> 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</p><p><strong>集合推导式</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="s">'abracadabra'</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s">'abc'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="p">{</span><span class="s">'r'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">}</span>
</pre></table></code></div></div><p><strong>两个集合间的运算</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s">'abracadabra'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s">'alacazam'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>                                  
<span class="p">{</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">-</span><span class="n">b</span>                              <span class="c1"># 集合a中包含而集合b中不包含的元素
</span><span class="p">{</span><span class="s">'r'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span>                              <span class="c1"># 集合a或b中包含的所有元素
</span><span class="p">{</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'m'</span><span class="p">,</span> <span class="s">'z'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>                              <span class="c1"># 集合a和b中都包含了的元素
</span><span class="p">{</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>                              <span class="c1"># 不同时包含于a和b的元素
</span><span class="p">{</span><span class="s">'r'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'m'</span><span class="p">,</span> <span class="s">'z'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">}</span>
</pre></table></code></div></div><h1 id="字典-dict">字典 Dict</h1><p>aDict.clear()<br /> 删除 aDict 的所有项</p><p>aDict.copy()<br /> 返回 aDict 的副本，是浅复制</p><p>aDict.fromkeys(seq[,val])<br /> 返回一个字典，其中的键来自 seq ，而值都被设置为 val （默认为 None ）。可直接使用字典类型 dict 将其作为类方法来调用</p><p>aDict.get(key[,default])<br /> 如果 aDict[key] 存在，就返回它；否则返回指定的默认值（默认为 None ）</p><p>aDict.setdefault(key[,default])<br /> 如果 aDict[key] 存在，就返回它；否则就返回指定的默认值（默认为 None ），并将 aDict[key] 设置为指定的默认值</p><p>aDict.items()<br /> 返回一个迭代器（实际上是一个视图），其中包含表示 aDict 各项的 (key, value) 对</p><p>aDict.keys()<br /> 返回一个迭代器（视图），其中包含 aDict 中所有的键</p><p>aDict.values()<br /> 返回一个迭代器（视图），其中包含 aDict 中所有的值（可能有重复的）</p><p>aDict.pop(key[, default])<br /> 如果key存在于字典中则将其移除并返回其值，否则返回default。如果default未给出且key不存在于字典中，则会引发KeyError。</p><p>aDict.popitem()<br /> 从 aDict 随机的删除一项，并将其以 元组(key, value) 对的方式返回</p><p>aDict.update(otherDict)<br /> 将 otherDict 中的每项都添加到 aDict （可能覆盖既有的项）。也可以像调用字典构造函数那样指定类似的参数</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">D</span> <span class="o">=</span> <span class="p">{</span><span class="s">'one'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'two'</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="n">D</span><span class="p">.</span><span class="n">update</span><span class="p">({</span><span class="s">'three'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'four'</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>  <span class="c1"># 传一个字典
</span><span class="n">D</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">five</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">six</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>  <span class="c1"># 传关键字
</span><span class="n">D</span><span class="p">.</span><span class="n">update</span><span class="p">([(</span><span class="s">'seven'</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="s">'eight'</span><span class="p">,</span> <span class="mi">8</span><span class="p">)])</span>  <span class="c1"># 传一个包含一个或多个元祖的列表
</span></pre></table></code></div></div><p><strong>字典推导式</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="s">'MBP'</span><span class="p">:</span> <span class="mi">268</span><span class="p">,</span> <span class="s">'HP'</span><span class="p">:</span> <span class="mi">125</span><span class="p">,</span> <span class="s">'DELL'</span><span class="p">:</span> <span class="mi">201</span><span class="p">,</span> <span class="s">'Lenovo'</span><span class="p">:</span> <span class="mi">199</span><span class="p">,</span> <span class="s">'acer'</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span>
<span class="c1"># 需求：提取上述电脑数量量⼤大于等于200的字典数据
</span><span class="n">count1</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">}</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">([(</span><span class="s">'sape'</span><span class="p">,</span> <span class="mi">4139</span><span class="p">),</span> <span class="p">(</span><span class="s">'guido'</span><span class="p">,</span> <span class="mi">4127</span><span class="p">),</span> <span class="p">(</span><span class="s">'jack'</span><span class="p">,</span> <span class="mi">4098</span><span class="p">)])</span>
<span class="p">{</span><span class="s">'sape'</span><span class="p">:</span> <span class="mi">4139</span><span class="p">,</span> <span class="s">'jack'</span><span class="p">:</span> <span class="mi">4098</span><span class="p">,</span> <span class="s">'guido'</span><span class="p">:</span> <span class="mi">4127</span><span class="p">}</span>
</pre></table></code></div></div><h1 id="元组-tuple">元组 Tuple</h1><p>元组与列表类似，不同之处在于<strong>元组的元素不能修改</strong></p><p>tup.index(x)<br /> 查找某个元素，如果数据存在返回对应的下标，否则报错</p><p>tup.count(x)<br /> 统计某个元素在当前元组出现的次数。</p><h1 id="字符串-string">字符串 String</h1><h2 id="格式相关">格式相关</h2><p><code class="language-plaintext highlighter-rouge">string.capitalize()</code><br /> 返回字符串的副本，但将第一个字符大写</p><p>string.title()<br /> 将字符串中所有单词的首字母都大写，并返回结果</p><p>string.upper()<br /> 将字符串中所有的字母都转换为大写，并返回结果</p><p>string.lower()<br /> 将字符串中所有的字母都转换为小写，并返回结果。只对ASCII字符有效，跟casefold相比范围窄</p><p>string.casefold()<br /> 返回经过标准化（normalize）后的字符串，标准化类似于转换为小写，但更适合用于对Unicode字符串进行不区分大小写的比较</p><p>string.swapcase()<br /> 将字符串中所有字母的大小写都反转，并返回结果</p><p>string.expandtabs([tabsize])<br /> 返回将字符串中的制表符展开为空格后的结果，可指定可选参数 tabsize（默认为8）</p><p>string.encode([encoding[,errors]])<br /> 返回使用指定编码和errors指定的错误处理方式对字符串进行编码的结果,参数errors的可能取值包含’strict’,’ignore’,’replace’</p><p>string.strip([chars])<br /> 将字符串开头和结尾的所有 chars 字符（默认为所有空白字符，如空格、制表符和换行符）都删除，并返回结果</p><p>string.rstrip([chars])<br /> 将字符串末尾所有的 chars 字符（默认为所有的空白字符，如空格、制表符和换行符）都删除，并返回结果</p><p>string.lstrip([chars])<br /> 将字符串开头所有的 chars （默认为所有的空白字符，如空格、制表符和换行符）都删除，并返回结果</p><p>string.zfill(width)<br /> 在字符串左边填充0（但将原来打头的 + 或 - 移到开头），使其长度为 width</p><p>string.center(width[, fillchar])<br /> 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</p><p>string.ljust(width[, fillchar])<br /> 返回一个长度为 max(len(string), width) 的字符串，其开头是当前字符串的副本，而末尾是使用fillchar 指定的字符（默认为空格）填充的</p><p>string.rjust(width[,fillchar])<br /> 返回一个长度为 max(len(string), width) 的字符串，其末尾为当前字符串的拷贝，而开头是使用fillchar 指定的字符（默认为空格）填充的</p><h2 id="查询相关">查询相关</h2><p>string.count(sub[, start[, end]])<br /> 计算子串 sub 出现的次数，可搜索范围限定为 string[start:end]</p><p>string.partition(sep)<br /> 在字符串中搜索 sep ，并返回元组 (sep 前面的部分 , sep, sep 后面的部分 ),如果sep不在字符串中,</p><p>string.rpartition(sep)<br /> 与 partition 相同，但从右往左搜索</p><p>string.index(sub[, start[, end]])<br /> 返回找到的第一个子串 sub 的索引，如果没有找到将引发ValueError 异常；还可将搜索范围限制为string[start:end]</p><p>string.rindex(sub[,start[,end]])<br /> 从右开始找子串 sub 的索引，如果没有找到这样的子串，就引发ValueError 异常；还可将搜索范围限定为 string[start:end]</p><p>string.find(sub[, start[, end]])<br /> 返回找到的第一个子串 sub 的索引，如果没有找到就返回 -1 ；还可将搜索范围限制为string[start:end]</p><p>string.rfind(sub[,start[,end]])<br /> 从右开始找子串的索引，如果没有找到这样的子串，就返回 -1 ；还可将搜索范围限定为 string[start:end]</p><h2 id="切割替换">切割替换</h2><p>string.replace(old,new[,max])<br /> 将字符串中的子串 old 替换为 new ，并返回结果；还可将最大替换次数限制为 max</p><p>string.join(sequence)<br /> 以指定字符串string作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</p><p>string.split([sep[, maxsplit]])<br /> 返回一个列表，其中包含以 sep 为分隔符对字符串进行划分得到的结果（参数 sep 默认空白字符）；还可将最大划分次数限制为 maxsplit</p><p>string.rsplit([sep[, maxsplit]])<br /> 与 split 相同，但指定了参数 maxsplit ，从右往左计算划分次数</p><p>string.splitlines([keepends])<br /> 返回一个列表，其中包含字符串中的所有行；如果参数 keepends 为 True ，将包含换行符在前一个元素中</p><h2 id="进行判断">进行判断</h2><p>string.endswith(suffix[,start[,end]])<br /> 检查字符串是否以 suffix 结尾，还可使用索引 start 和 end 来指定匹配范围</p><p>string.startswith(prefix[,start[,end]])<br /> 检查字符串是否以 prefix 打头,是则返回 True，否则返回 False；还可将匹配范围限制在索引 start 和end之间</p><p>string.isalnum()<br /> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False</p><p>string.isalpha()<br /> 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False</p><p>string.isdecimal()<br /> 检查字符串中的字符是否都是十进制数</p><p>string.isdigit()<br /> 如果字符串只包含数字则返回 True 否则返回 False</p><p>string.islower()<br /> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</p><p>string.isupper()<br /> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</p><p>string.isnumeric()<br /> 如果字符串中只包含数字字符，则返回 True，否则返回 False.数字可以是： Unicode 数字，全角数字（双字节），罗马数字，汉字数字。指数类似 ² 与分数类似 ½ 也属于数字。</p><p>string.isprintable()<br /> 检查字符串中的字符是否都是可打印的</p><p>string.isspace()<br /> 如果字符串中只包含空白，则返回 True，否则返回 False.</p><p>string.istitle()<br /> 如果字符串是标题化的(见 title())则返回 True，否则返回 False.位于非字母后面的字母都是大写的，且其他所有字母都是小写的</p><p>string.isidentifier()<br /> 检查字符串是否可用作Python标识符</p><h2 id="其他">其他</h2><p>string.format(…)<br /> 实现了标准的Python字符串格式设置。将字符串中用大括号分隔的字段替换为相应的参数，再返回结果</p><p>string.format_map(mapping)<br /> 类似于使用关键字参数调用 format ，只是参数是以映射的方式提供的</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span><span class="s">"{} {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">)</span>    <span class="c1"># 不设置指定位置，按默认顺序
</span><span class="s">'hello world'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">"{1} {0} {1}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">)</span>  <span class="c1"># 设置指定位置
</span><span class="s">'world hello world'</span>
<span class="o">&gt;&gt;&gt;</span><span class="k">print</span><span class="p">(</span><span class="s">"网站名：{name}, 地址 {url}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"百度"</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="s">"www.baidu.com"</span><span class="p">))</span>  <span class="c1"># 通过参数指定
</span></pre></table></code></div></div><p>str.maketrans(x[,y[,z]])<br /> 一个静态方法，它创建一个供 translate 使用的转换表。一个参数，该参数必须为字典；两个参数 x 和 y，x、y 必须是长度相等的字符串，并且 x 中每个字符映射到 y 中相同位置的字符；还可提供第三个参数 z 必须是字符串，其字符将被映射为 None，即删除该字符</p><p>string.translate(table)<br /> 根据转换表 table （这是使用 maketrans 创建的）对字符串中的所有字符都进行转换，并返回结果</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">intab</span> <span class="o">=</span> <span class="s">"aeiou"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">outtab</span> <span class="o">=</span> <span class="s">"12345"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">trantab</span> <span class="o">=</span> <span class="nb">str</span><span class="p">.</span><span class="n">maketrans</span><span class="p">(</span><span class="n">intab</span><span class="p">,</span> <span class="n">outtab</span><span class="p">)</span>   <span class="c1"># 制作翻译表
</span><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"this is string example....wow!!!"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="p">(</span><span class="nb">str</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">trantab</span><span class="p">))</span>
<span class="n">th3s</span> <span class="mi">3</span><span class="n">s</span> <span class="n">str3ng</span> <span class="mi">2</span><span class="n">x1mpl2</span><span class="p">....</span><span class="n">w4w</span><span class="err">!!!</span>
</pre></table></code></div></div><h2 id="字符串的格式化">字符串的格式化</h2><ol><li>最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中</ol><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="o">%</span><span class="n">s</span>	 <span class="n">格式化字符串</span>
<span class="o">%</span><span class="n">d</span>	 <span class="n">格式化整数</span>
<span class="o">%</span><span class="n">f</span>	 <span class="n">格式化浮点数字</span><span class="err">，</span><span class="n">可指定小数点后的精度</span>

<span class="n">格式化操作符辅助指令</span><span class="err">：</span>
    <span class="o">*</span>	    <span class="n">定义宽度或者小数点精度</span>
    <span class="o">-</span>	    <span class="n">用做左对齐</span>
    <span class="o">+</span>	    <span class="n">在正数前面显示加号</span><span class="p">(</span> <span class="o">+</span> <span class="p">)</span>
    <span class="o">&lt;</span><span class="n">sp</span><span class="o">&gt;</span>	<span class="n">在正数前面显示空格</span>
    <span class="c1">#	    在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')
</span>    <span class="mi">0</span>	    <span class="n">显示的数字前面填充</span><span class="s">'0'</span><span class="n">而不是默认的空格</span>
    <span class="o">%</span>	    <span class="s">'%%'</span><span class="n">输出一个单一的</span><span class="s">'%'</span>
    <span class="p">(</span><span class="n">var</span><span class="p">)</span>	<span class="n">映射变量</span><span class="p">(</span><span class="n">字典参数</span><span class="p">)</span>
    <span class="n">m</span><span class="p">.</span><span class="n">n</span><span class="p">.</span>	<span class="n">m</span> <span class="n">是显示的最小总宽度</span><span class="p">,</span><span class="n">n</span> <span class="n">是小数点后的位数</span><span class="p">(</span><span class="n">如果可用的话</span><span class="p">)</span>
</pre></table></code></div></div><ol><li>Python2.6 开始新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序。</ol><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span><span class="s">"{} {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">)</span>    <span class="c1"># 不设置指定位置，按默认顺序
</span><span class="s">'hello world'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">"{1} {0} {1}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">)</span>  <span class="c1"># 设置指定位置
</span><span class="s">'world hello world'</span>

<span class="k">print</span><span class="p">(</span><span class="s">"百度：{name}, 地址 {url}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"百度"</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="s">"www.baidu.com"</span><span class="p">))</span>

<span class="c1"># 通过字典设置参数
</span><span class="n">site</span> <span class="o">=</span> <span class="p">{</span><span class="s">"name"</span><span class="p">:</span> <span class="s">"百度"</span><span class="p">,</span> <span class="s">"url"</span><span class="p">:</span> <span class="s">"www.baidu.com"</span><span class="p">}</span>
<span class="k">print</span><span class="p">(</span><span class="s">"网站名：{name}, 地址 {url}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="o">**</span><span class="n">site</span><span class="p">))</span>
 
<span class="c1"># 通过列表索引设置参数
</span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">'百度'</span><span class="p">,</span> <span class="s">'www.baidu.com'</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="s">"网站名：{0[0]}, 地址 {0[1]}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">my_list</span><span class="p">))</span>  <span class="c1"># "0" 是必须的
</span>
<span class="c1"># 通过传入对象设置参数
</span><span class="k">class</span> <span class="nc">AssignValue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="n">my_value</span> <span class="o">=</span> <span class="n">AssignValue</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'value 为: {0.value}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">my_value</span><span class="p">))</span>  <span class="c1"># "0" 是可选的
</span></pre></table></code></div></div><ol><li><p>F字符串- f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</p><p>f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去</p><p>执行效率比前两种快</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> <span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="s">'baidu'</span>
 <span class="o">&gt;&gt;&gt;</span> <span class="sa">f</span><span class="s">'Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">'</span>  <span class="c1"># 替换变量
</span> <span class="s">'Hello baidu'</span>
 <span class="o">&gt;&gt;&gt;</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="s">'</span>         <span class="c1"># 使用表达式
</span> <span class="s">'3'</span>
 <span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="s">'baidu'</span><span class="p">,</span> <span class="s">'url'</span><span class="p">:</span> <span class="s">'www.baidu.com'</span><span class="p">}</span>
 <span class="o">&gt;&gt;&gt;</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">w</span><span class="p">[</span><span class="s">"name"</span><span class="p">]</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">w</span><span class="p">[</span><span class="s">"url"</span><span class="p">]</span><span class="si">}</span><span class="s">'</span>
 <span class="s">'baidu: www.baidu.com'</span>
</pre></table></code></div></div></ol><h1 id="数字-number">数字 Number</h1><p>Python 支持三种不同的数值类型：</p><ul><li><strong>整型(Int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。<li><strong>浮点型(float)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）<li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</ul><h2 id="按位运算符">按位运算符</h2><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">按位运算符是把数字看作二进制来进行计算的</span><span class="err">。</span>  
<span class="n">a</span> <span class="o">=</span> <span class="mi">0011</span> <span class="mi">1100</span>   <span class="c1"># a为60  
</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0000</span> <span class="mi">1101</span>   <span class="c1"># b为13 
</span><span class="o">--------------</span>
<span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>   <span class="o">=</span>   <span class="mi">0000</span> <span class="mi">1100</span>  <span class="c1"># 输出结果 12
</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span>   <span class="o">=</span>   <span class="mi">0011</span> <span class="mi">1101</span>  <span class="c1"># 输出结果 61
</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span>   <span class="o">=</span>   <span class="mi">0011</span> <span class="mi">0001</span>  <span class="c1"># 输出结果 49
</span><span class="o">~</span><span class="n">a</span>      <span class="o">=</span>   <span class="mi">1100</span> <span class="mi">0011</span>  <span class="c1"># 输出结果 -61
</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>  <span class="o">=</span>   <span class="mi">1111</span> <span class="mi">0000</span>  <span class="c1"># 输出结果 240 
</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>  <span class="o">=</span>   <span class="mi">0000</span> <span class="mi">1111</span>  <span class="c1"># 输出结果 15 
</span>
<span class="o">&amp;</span>	<span class="n">按位与运算符</span><span class="err">：</span><span class="n">参与运算的两个值</span><span class="p">,</span><span class="n">如果两个相应位都为1</span><span class="p">,</span><span class="n">则该位的结果为1</span><span class="p">,</span><span class="n">否则为0</span>
<span class="o">|</span>	<span class="n">按位或运算符</span><span class="err">：</span><span class="n">只要对应的两个二进位有一个为1时</span><span class="err">，</span><span class="n">结果位就为1</span>
<span class="o">^</span>	<span class="n">按位异或运算符</span><span class="err">：</span><span class="n">当两对应的二进位相异时</span><span class="err">，</span><span class="n">结果为1</span>	
<span class="o">~</span>	<span class="n">按位取反运算符</span><span class="err">：</span><span class="n">对数据的每个二进制位取反</span><span class="p">,</span><span class="n">即把1变为0</span><span class="p">,</span><span class="n">把0变为1</span><span class="p">;</span><span class="o">~</span><span class="n">x</span> <span class="n">类似于</span> <span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span>
<span class="o">&lt;&lt;</span>	<span class="n">左移动运算符</span><span class="err">：</span><span class="n">二进位全部左移若干位</span><span class="err">，</span><span class="n">由</span><span class="s">"&lt;&lt;"</span><span class="n">右边的数指定移动的位数</span><span class="err">，</span><span class="n">高位丢弃</span><span class="err">，</span><span class="n">低位补0</span><span class="err">。</span>	
<span class="o">&gt;&gt;</span>	<span class="n">右移动运算符</span><span class="err">：</span><span class="n">把</span><span class="s">"&gt;&gt;"</span><span class="n">左边的运算数的各二进位全部右移若干位</span><span class="err">，</span><span class="s">"&gt;&gt;"</span><span class="n">右边的数指定移动的位数</span>
</pre></table></code></div></div><h2 id="python运算符优先级">Python运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符<th style="text-align: left">描述<tbody><tr><td style="text-align: left">**<td style="text-align: left">指数 (最高优先级)<tr><td style="text-align: left">~ + -<td style="text-align: left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)<tr><td style="text-align: left">* / % //<td style="text-align: left">乘，除，求余数和取整除<tr><td style="text-align: left">+ -<td style="text-align: left">加法减法<tr><td style="text-align: left">» «<td style="text-align: left">右移，左移运算符<tr><td style="text-align: left">&amp;<td style="text-align: left">位 ‘AND’<tr><td style="text-align: left">^ |<td style="text-align: left">位运算符<tr><td style="text-align: left">&lt;= &lt; &gt; &gt;=<td style="text-align: left">比较运算符<tr><td style="text-align: left">== !=<td style="text-align: left">等于运算符<tr><td style="text-align: left">= %= /= //= -= += *= **=<td style="text-align: left">赋值运算符<tr><td style="text-align: left">is is not<td style="text-align: left">身份运算符<tr><td style="text-align: left">in not in<td style="text-align: left">成员运算符<tr><td style="text-align: left">not and or<td style="text-align: left">逻辑运算符</table></div><h2 id="常用的数据类型转换">常用的数据类型转换</h2><div class="table-wrapper"><table><thead><tr><th style="text-align: center">函数<th style="text-align: center">说明<tbody><tr><td style="text-align: center">int(x [,base ])<td style="text-align: center">将x转换为一个整数<tr><td style="text-align: center">float(x )<td style="text-align: center">将x转换为一个浮点数<tr><td style="text-align: center">complex(real [,imag ])<td style="text-align: center">创建一个复数，real为实部，imag为虚部<tr><td style="text-align: center">str(x )<td style="text-align: center">将对象 x 转换为字符串<tr><td style="text-align: center">repr(x )<td style="text-align: center">将对象 x 转换为表达式字符串<tr><td style="text-align: center">eval(str )<td style="text-align: center">用来计算在字符串中的有效Python表达式,并返回一个对象<tr><td style="text-align: center">tuple(s )<td style="text-align: center">将序列 s 转换为一个元组<tr><td style="text-align: center">list(s )<td style="text-align: center">将序列 s 转换为一个列表<tr><td style="text-align: center">chr(x )<td style="text-align: center">将一个整数转换为一个Unicode字符<tr><td style="text-align: center">ord(x )<td style="text-align: center">将一个字符转换为它的ASCII整数值<tr><td style="text-align: center">hex(x )<td style="text-align: center">将一个整数转换为一个十六进制字符串<tr><td style="text-align: center">oct(x )<td style="text-align: center">将一个整数转换为一个八进制字符串<tr><td style="text-align: center">bin(x )<td style="text-align: center">将一个整数转换为一个二进制字符串</table></div><h2 id="数学函数">数学函数</h2><div class="table-wrapper"><table><thead><tr><th style="text-align: left">函数<th style="text-align: left">返回值 ( 描述 )<tbody><tr><td style="text-align: left">abs(x)<td style="text-align: left">返回数字的绝对值，如abs(-10) 返回 10<tr><td style="text-align: left">ceil(x)<td style="text-align: left">返回数字的上入整数，如math.ceil(4.1) 返回 5<tr><td style="text-align: left">cmp(x, y)<td style="text-align: left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 **Python 3 已废弃，使用 (x&gt;y)-(x。<tr><td style="text-align: left">exp(x)<td style="text-align: left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045<tr><td style="text-align: left">fabs(x)<td style="text-align: left">返回数字的绝对值，如math.fabs(-10) 返回10.0<tr><td style="text-align: left">floor(x)<td style="text-align: left">返回数字的下舍整数，如math.floor(4.9)返回 4<tr><td style="text-align: left">log(x)<td style="text-align: left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0<tr><td style="text-align: left">log10(x)<td style="text-align: left">返回以10为基数的x的对数，如math.log10(100)返回 2.0<tr><td style="text-align: left">max(x1,x2,…)<td style="text-align: left">返回给定参数的最大值，参数可以为序列。<tr><td style="text-align: left">min(x1,x2,…)<td style="text-align: left">返回给定参数的最小值，参数可以为序列。<tr><td style="text-align: left">modf(x)<td style="text-align: left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。<tr><td style="text-align: left">pow(x, y)<td style="text-align: left">x**y 运算后的值。<tr><td style="text-align: left">round(x [,n])<td style="text-align: left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong><tr><td style="text-align: left">sqrt(x)<td style="text-align: left">返回数字x的平方根。</table></div><h1 id="简单语句复合语句">简单语句&amp;复合语句</h1><h2 id="简单语句">简单语句</h2><p>简单语句只包含一个逻辑行。</p><ol><li><p>表达式语句</p><p>表达式本身可以为语句。这在表达式为函数调用或文档字符串时特别有用。</p><p>示例：</p><p>“This module contains SPAM-related functions.”</p><li><p>断言语句</p><p>断言语句检查条件是否满足，如果不满足，就引发 AssertionError 异常（并可提供错误消息）。</p><p>示例：</p><p>assert age &gt;= 12, ‘Children under the age of 12 are not allowed’</p><li><p>赋值语句</p><p>赋值语句将变量与值关联起来。可通过序列解包同时给多个变量赋值，还可进行链式赋值。</p><p>示例：</p><p>x = 42 # 简单赋值</p><p>name, age = ‘Gumby’, 60 # 序列解包</p><p>x = y = z = 10 # 链式赋值</p><li><p>增强赋值语句</p><p>可使用运算符来增强赋值。在这种情况下，将对变量的当前值和指定的值执行运算符指定的运算，并将变量重新关联到结果。如果原来的值是可变的，可能修改原来的值（并让变量依然关联到原来的值）。</p><li><p>pass 语句</p><p>pass 语句不执行任何操作，可用作占位符。在语法要求的代码块中，如果你不想执行任何操作，可让它只包含 pass 语句。</p><li><p>del 语句</p><p>del 语句用于解除变量和属性与值的关联以及将数据结构（映射或序列）的一部分（如（位置、切片或存储槽）删除。不能直接使用它来删除值，因为值只能通过垃圾收集来删除。</p><li><p>return 语句</p><p>return 语句结束函数的执行并返回一个值。如果没有指定值，将返回 None 。</p><li><p>yield 语句</p><p>yield 语句暂停执行生成器，并返回一个值。生成器是一种迭代器，可用于 for 循环中。</p><li><p>raise 语句</p><p>raise 语句引发异常。调用它时可不提供任何参数（在 except 子句中用于重新引发当前捕获的异常），提供 Exception 的一个子类和一个可选参数（在这种情况下，将创建一个实例）或提供Exception 子类的一个实例。</p><li><p>break 语句</p><p>break 语句结束它所属的循环语句（ for 或 while 语句），并接着执行该循环语句后面的语句。</p><li><p>continue 语句</p><p>continue 语句类似于 break 语句，但结束所属循环的当前迭代而不是整个循环，即跳到下一次迭代开头继续执行。</p><li><p>import 语句</p><p>import 语句用于从外部模块导入名称（与函数、类或其他值相关联的变量）。这也包括 from__future__ import 语句，它们用于导入在未来的Python版本中将包含在标准中的功能。</p><li><p>global 语句</p><p>global 语句用于将变量标记为全局的。在函数中，可使用它给全局变量重新赋值。使用 global语句通常被视为糟糕的编程风格，因此应尽可能避免。</p><li><p>nonlocal 语句</p><p>类似于 global 语句，但引用内部函数（闭包）的外部作用域。换而言之，如果你在一个函数内定义了另一个函数并返回它，这个函数就可引用并修改外部函数中的变量，条件是使用nonlocal 来标记它。</p></ol><h2 id="复合语句">复合语句</h2><p>复合语句包含一组其他的语句（代码块）。</p><ol><li><p>if 语句</p><p>if 语句用于有条件地执行，可包含 elif 和 else 子句。 示例：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
 	<span class="k">print</span><span class="p">(</span><span class="s">'Less than ten'</span><span class="p">)</span>
 <span class="k">elif</span> <span class="mi">10</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
 	<span class="k">print</span><span class="p">(</span><span class="s">'Less than twenty'</span><span class="p">)</span>
 <span class="k">else</span><span class="p">:</span>
 	<span class="k">print</span><span class="p">(</span><span class="s">'Twenty or more'</span><span class="p">)</span>
</pre></table></code></div></div><li><p>while 语句</p><p>while 语句用于在指定条件为真时反复地执行（循环），可包含 else 子句［这种子句将在循环正常结束（如没有执行任何 break 和 return 语句）时执行］。</p><p>示例：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
 <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
 	<span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
 	<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></table></code></div></div><li><p>for 语句</p><p>for 语句用于对序列的元素或其他可迭代对象（包含返回迭代器的方法 <strong>iter</strong> 的对象）反复地执行（循环），可包含 else 子句［这种子句将在循环正常结束（如没有执行任何 break 和 return语句）时执行］。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
 <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
 <span class="k">print</span><span class="p">(</span><span class="s">'Ignition!'</span><span class="p">)</span>
</pre></table></code></div></div><li><p>try 语句</p><p>try 语句用于执行可能发生异常的代码段，让程序能够捕获这些异常并执行异常处理代码。try 语句可包含多个 except 子句（用于处理异常）和 finally 子句（这种子句不管情况如何都将执行，可用于执行清理工作）。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> <span class="k">try</span><span class="p">:</span>
 	<span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span>
 <span class="k">except</span> <span class="nb">ZeroDivisionError</span><span class="p">:</span>
 	<span class="k">print</span><span class="p">(</span><span class="s">"Can't divide anything by zero."</span><span class="p">)</span>
 <span class="k">else</span><span class="p">:</span>
     <span class="k">print</span><span class="p">(</span><span class="s">"OK"</span><span class="p">)</span>
 <span class="k">finally</span><span class="p">:</span>
 	<span class="k">print</span><span class="p">(</span><span class="s">"Done trying to calculate 1 / 0"</span><span class="p">)</span>
</pre></table></code></div></div><li><p>with 语句</p><p>with 语句用于包装使用上下文管理器的代码块，让管理器能够执行一些设置和清理操作。例如，可将文件用作上下文管理器，这样它们将在执行清理工作时关闭自己。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"somefile.txt"</span><span class="p">)</span> <span class="k">as</span> <span class="n">myfile</span><span class="p">:</span>
 	<span class="n">dosomething</span><span class="p">(</span><span class="n">myfile</span><span class="p">)</span>
 <span class="c1"># 到这里时文件已关闭
</span></pre></table></code></div></div><li><p>函数定义</p><p>函数定义用于创建函数对象以及将全局或局部变量与函数对象关联起来。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
 	<span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
</pre></table></code></div></div><li><p>类定义</p><p>类定义用于创建类对象以及将全局或局部变量与类对象关联起来。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="k">class</span> <span class="nc">Doubler</span><span class="p">:</span>
 	<span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
 		<span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
 	<span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
 		<span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">*=</span> <span class="mi">2</span>
</pre></table></code></div></div></ol><h1 id="内置函数">内置函数</h1><p>abs(number)<br /> 返回数字的绝对值</p><p>all(iterable)<br /> 如果 iterable 的所有元素都为真值，就返回 True ；否则返回 False</p><p>any(iterable)<br /> 如果 iterable 的所有元素都为假值，就返回 False ；否则返回 True</p><p>ascii(object)<br /> ascii() 函数类似 repr() 函数, 返回一个表示对象的字符串, 但是对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \x, \u 或 \U 编码的字符。</p><p>bin(integer)<br /> 将整数转换为以字符串表示的二进制字面量</p><p>bool(x)<br /> 将 x 解读为布尔值，并返回 True 或 False</p><p>bytearray([string,[encoding[,errors]]] )<br /> 创建一个 bytearray ，可根据指定的字符串给它赋值，还可指定编码和错误处理方式</p><p>bytes([string, [encoding[, errors]]] )<br /> 类似于 bytearray ，但返回一个可修改的 bytes 对象</p><p>callable(object)<br /> 检查对象是否是可调用的.callable() 函数用于检查一个对象是否是可调用的。如果返回 True，object仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。对于函数、方法、lambda函式、 类以及实现了 <strong>call</strong> 方法的类实例, 它都返回 True。</p><p>chr(number)<br /> 返回一个字符，其Unicode码点为指定的数字</p><p>classmethod(func)<br /> 根据实例方法创建一个类方法</p><p>complex(real[, imag] )<br /> 返回一个复数，其实部和虚部分别为指定的值,例如complex(1,2) –&gt; 1+2j</p><p>dict([mapping-or-sequence] )<br /> 创建一个字典。可根据另一个映射或 (key, value) 列表来创建，也可使用关键字参数来调用</p><p>dir([object] )<br /> 列出当前可见作用域中的（大部分）命令，或列出指定对象的（大部分）属性</p><p>divmod(a, b)<br /> 返回 (a // b, a % b) （对于浮点数，有一些特殊规则）,python3该函数不支持复数</p><p>enumerate(iterable)<br /> 迭代 iterable 中所有项的 (index, item) 。可提供关键字参数 start ，以便不从开头开始迭代</p><p>eval(string[, globals[, locals]])<br /> 计算以字符串表示的表达式，还可在指定的全局和局部作用域内进行</p><p>float(object)<br /> 将字符串或数字转换为浮点数</p><p>format(value[, format_spec])<br /> 返回对指定字符串设置格式后的结果。格式设置规范的作用与字符串方法 format 中相同</p><p>frozenset([iterable])<br /> 创建一个不可修改的集合，这意味着可将其添加到其他集合中</p><p>globals()<br /> 返回一个表示当前全局作用域的字典</p><p>help([object])<br /> 调用内置的帮助系统，或打印有关指定对象的帮助信息</p><p>hex(number)<br /> 将数字转换为十六进制字符串</p><p>id(object)<br /> 返回指定对象的独一无二的ID</p><p>input([prompt])<br /> 以字符串的方式返回用户输入的数据，还可显示指定的提示语</p><p>int(object[, radix])<br /> 将字符串或数字转换为整数，还可指定进制单位,默认十进制</p><p>isinstance(object, classinfo)<br /> 检查 object 是否是 classinfo 的实例，其中参数 classinfo 可以是类对象、类型对象或类和类型对象元组</p><p>issubclass(class1, class2)<br /> 检查 class1 是否是 class2 的子类（每个类都被视为是它自己的子类）</p><p>iter(object[, sentinel])<br /> 返回一个迭代器对象，即 object.<strong>iter</strong>() 。这个迭代器对象用于迭代序列（如果 object 支持 <strong>getitem</strong> ）。如果指定了 sentinel ，这个迭代器将不断调用 object ，直到返回的是 sentinel</p><p>len(object)<br /> 返回指定对象的长度（包含的项数）</p><p>list([sequence])<br /> 创建一个列表，也可根据指定的序列创建列表</p><p>locals()<br /> 返回一个表示当前局部作用域的字典（请不要修改这个字典）</p><p>max(object1, [object2, …])<br /> 如果 object1 不是空序列，就返回其中最大的元素；否则返回提供的参数（ object1 、 object2 等）中最大的那个</p><p>min(object1, [object2, …])<br /> 如果 object1 不是空序列，就返回其中最小的元素；否则返回提供的参数（ object1 、 object2 等）中最小的那个</p><p>next(iterator[, default])<br /> 返回 iterator.<strong>next</strong>() 的值，还可指定默认值，它指定在到达了迭代器末尾时将返回的值</p><p>object()<br /> 返回一个 object 实例； object 是所有新式类的基类</p><p>oct(number)<br /> 将整数转换为八进制字符串</p><p>open(filename[, mode[, bufsize]])<br /> 打开一个文件并返回一个文件对象（还有其他的可选参数，如指定编码和错误处理方式的参数）</p><p>ord(char)<br /> 返回指定字符的Unicode码点</p><p>pow(x, y[, z])<br /> 返回 x 的 y 次方，还可将结果对 z 求模</p><p>print(*objects, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False)</p><ul><li>objects – 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。<li>sep – 用来间隔多个对象，默认值是一个空格。<li>end – 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。<li>file – 要写入的文件对象。<li>flush – 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。</ul><p>property([fget[, fset[, fdel[, doc]]]])<br /> 根据一组存取函数创建一个特性。</p><p>range([start, ]stop[, step])<br /> 根据参数 start （包含，默认为0）、 stop （不包含）和 step （默认为1）以序列的方式返回指定范围内的一系列值</p><p>repr(object)<br /> 返回对象的字符串表示，通常用作 eval 的参数,返回的是解释器易读的，类似于”hello\n”,str()返回的是用户易读的，会将”\n”翻译成换行</p><p>reversed(sequence)<br /> 返回一个反向迭代序列的迭代器</p><p>round(float[, n])<br /> 将指定的浮点数圆整到小数点后 n 位（默认为零位）。关于详尽的圆整规则，请参阅官方文档</p><p>set([iterable])<br /> 返回一个集合；如果指定了 iterable ， 该集合的元素将是从中取得的</p><p>staticmethod(func)<br /> 根据实例方法创建一个静态（类）方法</p><p>str(object)<br /> 返回指定对象的格式良好的字符串表示</p><p>sum(iterable[, start])<br /> 计算数字序列中所有元素的总和;iterable -可迭代对象，如：列表、元组、集合,start -指定起始相加的参数，如果没有设置这个值，默认为0,然后返回结果</p><p>super([type[, obj/type]])<br /> 返回一个将方法调用委托给超类的代理</p><p>tuple([sequence])<br /> 创建一个元组，如果指定了可选参数 sequence ，该元组包含的项将与该参数指定的序列相同</p><p>type(object）<br /> 返回指定对象的类型</p><p>type(name, bases, dict)<br /> 返回一个新的类型对象，其名称、基类和作用域由相应的参数指定</p><p>vars([object])<br /> 返回一个表示局部作用域的字典或一个包含指定对象的属性的字典（请不要修改这个字典）</p><p>zip(sequence1, …)<br /> 返回一个元组迭代器，其中每个元组都包含提供序列的相应项。返回的列表与提供的最短序列等长</p><p>map(function, sequence, …)<br /> 接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">]</span>
</pre></table></code></div></div><p>reduce(function, sequence)<br /> 把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="mi">13579</span>
</pre></table></code></div></div><p>filter(function, sequence)<br /> 用于过滤序列。接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。返回的是一个Iterator</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    	<span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_odd</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]))</span>  
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># 结果: [1, 5, 9, 15]
</span></pre></table></code></div></div><p>sorted(iterable[, key][, reverse]) <br /> 返回一个排序后的列表，其中的元素来自 iterable 。key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。第三个参数reverse=True 表示反向排序，默认是False .注意点是：key处理元素之后对处理的元素排序，排完序之后会让原始的元素按照这个顺序排列，即原始的序列中元素没变成处理之后的值</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">([</span><span class="mi">36</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">abs</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">([</span><span class="s">'bob'</span><span class="p">,</span> <span class="s">'about'</span><span class="p">,</span> <span class="s">'Zoo'</span><span class="p">,</span> <span class="s">'Credit'</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">[</span><span class="s">'Zoo'</span><span class="p">,</span> <span class="s">'Credit'</span><span class="p">,</span> <span class="s">'bob'</span><span class="p">,</span> <span class="s">'about'</span><span class="p">]</span>
</pre></table></code></div></div><p>hasattr(object, name)<br /> 判断一个对象里面是否有name属性或者name方法，返回BOOL值，有name特性返回True， 否则返回False。需要注意的是name要用引号包起来</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">test</span><span class="p">():</span>
<span class="p">...</span>     <span class="n">name</span><span class="o">=</span><span class="s">"xiaohua"</span>
<span class="p">...</span>     <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="p">...</span>             <span class="k">return</span> <span class="s">"HelloWord"</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">=</span><span class="n">test</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"name"</span><span class="p">)</span> <span class="c1">#判断对象有name属性
</span><span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"run"</span><span class="p">)</span>  <span class="c1">#判断对象有run方法
</span><span class="bp">True</span>
</pre></table></code></div></div><p>getattr(object, name[,default])<br /> 获取对象object的name属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。如果不提供该参数，在没有对应属性时，将触发 AttributeError。 需要注意的是，如果是返回的对象的方法，返回的是方法的内存地址，如果需要运行这个方法，可以在后面添加一对括号。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">test</span><span class="p">():</span>
<span class="p">...</span>     <span class="n">name</span><span class="o">=</span><span class="s">"xiaohua"</span>
<span class="p">...</span>     <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="p">...</span>             <span class="k">return</span> <span class="s">"HelloWord"</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">=</span><span class="n">test</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"name"</span><span class="p">)</span> <span class="c1">#获取name属性，存在就打印出来。
</span><span class="s">'xiaohua'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"run"</span><span class="p">)</span>  <span class="c1">#获取run方法，存在就打印出方法的内存地址。
</span><span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">test</span><span class="p">.</span><span class="n">run</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="p">.</span><span class="n">test</span> <span class="n">instance</span> <span class="n">at</span> <span class="mh">0x0269C878</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"run"</span><span class="p">)()</span>  <span class="c1">#获取run方法，后面加括号可以将这个方法运行。
</span><span class="s">'HelloWord'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"age"</span><span class="p">)</span>  <span class="c1">#获取一个不存在的属性。
</span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">AttributeError</span><span class="p">:</span> <span class="n">test</span> <span class="n">instance</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s">'age'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"age"</span><span class="p">,</span><span class="s">"18"</span><span class="p">)</span>  <span class="c1">#若属性不存在，返回一个默认值。
</span><span class="s">'18'</span>
</pre></table></code></div></div><p>setattr(object, name, values)<br /> 给对象的属性赋值，若属性不存在，先创建再赋值。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">test</span><span class="p">():</span>
<span class="p">...</span>     <span class="n">name</span><span class="o">=</span><span class="s">"xiaohua"</span>
<span class="p">...</span>     <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="p">...</span>             <span class="k">return</span> <span class="s">"HelloWord"</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">=</span><span class="n">test</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"age"</span><span class="p">)</span>   <span class="c1">#判断属性是否存在
</span><span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"age"</span><span class="p">,</span> <span class="s">"18"</span><span class="p">)</span>   <span class="c1">#为属相赋值，并没有返回值
</span><span class="o">&gt;&gt;&gt;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"age"</span><span class="p">)</span>    <span class="c1">#属性存在了
</span><span class="bp">True</span>
</pre></table></code></div></div><p>delattr(object, name)<br /> 删除指定对象的指定属性，相等于 del x.foobar。name – 必须是对象的属性，如果没有name属性会引发异常</p><h1 id="匿名函数">匿名函数</h1><p>匿名函数的语法结构:</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">lambda</span> <span class="p">[</span><span class="n">形参1</span><span class="p">],</span> <span class="p">[</span><span class="n">形参2</span><span class="p">],</span> <span class="p">...</span> <span class="p">:</span> <span class="p">[</span><span class="n">单行表达式</span><span class="p">]</span> <span class="n">或</span> <span class="p">[</span><span class="n">函数调用</span><span class="p">]</span>
</pre></table></code></div></div><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">]</span>
</pre></table></code></div></div><p>关键字lambda表示匿名函数，冒号前面的x表示函数参数</p><p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="o">&lt;</span><span class="k">lambda</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x101c6ef28</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">25</span>
</pre></table></code></div></div><ol><li>匿名函数中<strong>不能使用 if 语句、while 循环、for 循环</strong>, 只能编写单行的表达式，或函数调用, 普通函数都可以.<li>匿名函数中返回结果<strong>不需要使用 return</strong>, 表达式的运行结果就是返回结果, 普通函数返回结果必须 return.<li>匿名函数中也可以不返回结果. 例如: <code class="language-plaintext highlighter-rouge">lambda : print('hello world')</code></ol><h1 id="面向对象">面向对象</h1><p>⾯面向对象就是将编程当成是⼀一个事物，对外界来说，事物是直接使⽤用的，不不⽤用去管他内部 的情况。⽽而编程就是设置事物能够做什什么事。</p><p><strong>面向对象三⼤大特性: 封装, 继承, 多态</strong></p><p><strong>封装</strong> 将属性和⽅方法书写到类的⾥里里⾯面的操作即为封装 封装可以为属性和⽅方法添加私有权限</p><p><strong>继承</strong></p><ul><li>⼦子类默认拥有⽗父类的所有属性和⽅方法<li>⼦子类重写⽗父类同名⽅方法和属性<li>⼦子类调⽤用⽗父类同名⽅方法和属性</ul><p><strong>多态</strong> 传⼊入不不同的对象，产⽣生不不同的结果。多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，多态性增强了软件的灵活性。（多态的概念依赖于继承）。</p><p><strong>类属性</strong></p><p>类属性就是 类对象 所拥有的属性，它被 该类的所有实例例对象 所共有。 类属性可以使⽤用 类对象 或 实例例对象 访问。</p><p>实例属性 要求 每个对象 为其 单独开辟一份内存空间 来记录数据，⽽而 类属性 为全类所共有 ，仅占⽤用一份内存，更更加节省内存空间。</p><p>类属性只能通过类对象修改，不不能通过实例例对象修改，如果通过实例例对象修改类属性，表示的是创建了了 一个实例例属性。</p><p><strong>实例例属性</strong></p><p>实例属性不不能通过类访问</p><p><strong>类的私有属性</strong></p><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><p><strong>类方法</strong></p><p>第一个形参是类对象的⽅方法 需要用装饰器器 @classmethod 来标识其为类⽅方法，对于类⽅方法，第一个参数必须是类对象，一般以 cls 作为第一个参数。</p><p>当方法中 需要使⽤用类对象 (如访问私有类属性等)时，定义类⽅方法</p><p><strong>静态方法</strong></p><p>需要通过装饰器器 @staticmethod 来进⾏行行修饰，静态⽅方法既不不需要传递类对象也不不需要传递实例例对象 （形参没有self/cls）。 静态方法 也能够通过 实例例对象 和 类对象 去访问。</p><p>当方法中 既不不需要使⽤用实例例对象(如实例例对象，实例例属性)，也不需要使⽤用类对象 (如类属性、类方 法、创建实例等)时，定义静态方法 取消不需要的参数传递，有利利于 减少不不必要的内存占⽤用和性能消耗</p><p><strong>类的私有方法</strong></p><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><p><strong>在类定义中，对所有以两个下划线打头的名称都进行转换，即在开头加上一个下划线和类名。</strong></p><h1 id="异常处理">异常处理</h1><p><strong>常见异常</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">异常名称<th style="text-align: left">描述<tbody><tr><td style="text-align: left">BaseException<td style="text-align: left">所有异常的基类<tr><td style="text-align: left">Exception<td style="text-align: left">常规错误的基类<tr><td style="text-align: left">StopIteration<td style="text-align: left">迭代器没有更多的值<tr><td style="text-align: left">ZeroDivisionError<td style="text-align: left">除(或取模)零 (所有数据类型)<tr><td style="text-align: left">AssertionError<td style="text-align: left">断言语句失败<tr><td style="text-align: left">AttributeError<td style="text-align: left">对象没有这个属性<tr><td style="text-align: left">IOError<td style="text-align: left">输入/输出操作失败<tr><td style="text-align: left">OSError<td style="text-align: left">操作系统错误<tr><td style="text-align: left">ImportError<td style="text-align: left">导入模块/对象失败<tr><td style="text-align: left">IndexError<td style="text-align: left">序列中没有此索引(index)<tr><td style="text-align: left">KeyError<td style="text-align: left">映射中没有这个键<tr><td style="text-align: left">NameError<td style="text-align: left">未声明/初始化对象 (没有属性)<tr><td style="text-align: left">SyntaxError<td style="text-align: left">Python 语法错误<tr><td style="text-align: left">IndentationError<td style="text-align: left">缩进错误<tr><td style="text-align: left">TabError<td style="text-align: left">Tab 和空格混用<tr><td style="text-align: left">TypeError<td style="text-align: left">对类型无效的操作<tr><td style="text-align: left">ValueError<td style="text-align: left">传入无效的参数</table></div><p><strong><code class="language-plaintext highlighter-rouge">assert</code>断言</strong></p><p>用于判断一个表达式，在表达式条件为 false 的时候触发异常。断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况</p><p><strong><code class="language-plaintext highlighter-rouge">try/except</code>异常捕捉</strong></p><p>try 语句按照如下方式工作；</p><ul><li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。<li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。<li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。<li>如果一个异常没有与任何的 excep 匹配，那么这个异常将会传递给上层的 try 中。</ul><p>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">try</span><span class="p">:</span>
    <span class="c1"># 执行代码
</span>    <span class="c1"># TODO
</span><span class="k">except</span> <span class="n">oneException</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
    <span class="c1"># 发生异常时执行代码
</span>    <span class="c1"># TODO
</span><span class="k">else</span><span class="p">:</span>
    <span class="c1"># 没有异常时执行代码
</span>    <span class="c1"># TODO
</span><span class="k">finally</span><span class="p">:</span>
    <span class="c1"># 不管有没有异常都会执行代码
</span>    <span class="c1"># TODO
</span></pre></table></code></div></div><p><strong>抛出异常</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</pre></table></code></div></div><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span><span class="k">try</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">NameError</span><span class="p">(</span><span class="s">'HiThere'</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">NameError</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'An exception flew by!'</span><span class="p">)</span>
        <span class="k">raise</span>
   
<span class="n">An</span> <span class="n">exception</span> <span class="n">flew</span> <span class="n">by</span><span class="err">!</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
<span class="nb">NameError</span><span class="p">:</span> <span class="n">HiThere</span>
</pre></table></code></div></div><p><strong>自定义异常</strong></p><p>自定义异常类继承自 Exception 类，可以直接继承，或者间接继承</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span><span class="k">class</span> <span class="nc">MyError</span><span class="p">(</span><span class="nb">Exception</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">().</span><span class="n">__init</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
   
<span class="o">&gt;&gt;&gt;</span> <span class="k">try</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MyError</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">MyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'My exception occurred, value:'</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
   
<span class="n">My</span> <span class="n">exception</span> <span class="n">occurred</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">raise</span> <span class="n">MyError</span><span class="p">(</span><span class="s">'oops!'</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
<span class="n">__main__</span><span class="p">.</span><span class="n">MyError</span><span class="p">:</span> <span class="s">'oops!'</span>
</pre></table></code></div></div><p><strong>预定义的清理行为</strong></p><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1"># 迭代行为
</span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">"myfile.txt"</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">""</span><span class="p">)</span>

<span class="c1"># 上下文管理
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"myfile.txt"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">""</span><span class="p">)</span>
</pre></table></code></div></div><h1 id="模块与包">模块与包</h1><p><strong>模块</strong></p><p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。模块能定义函数，类和变量，模块里也能包含可执行的代码。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">模块名</span>
<span class="kn">from</span> <span class="nn">模块名</span> <span class="kn">import</span> <span class="n">功能名</span>
<span class="kn">from</span> <span class="nn">模块名</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">模块名</span> <span class="k">as</span> <span class="n">别名</span>
<span class="kn">from</span> <span class="nn">模块名</span> <span class="kn">import</span> <span class="n">功能名</span> <span class="k">as</span> <span class="n">别名</span>
</pre></table></code></div></div><p>当你导入一个模块，Python解析器对模块位置的搜索顺序是：</p><ol><li>当前目录<li>如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。<li>如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/<li>模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</ol><p>如果一个模块文件中有 __all__(一个列表,元素是当前文件的变量名的字符串形式)变量，当使用 from xxx import * 导入时，只能导入这个列表中的元素。</p><p>当前文件有一个变量__name__,如果是在本文件中执行,__name__值为”__main__“,如果在其他模块导入值为文件名</p><p><strong>包</strong></p><p>包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为 __init__.py 文件，那么这个文件夹就称之为包。</p><h1 id="文件操作">文件操作</h1><h2 id="open函数">open()函数</h2><p>open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数,如果该文件无法被打开，会抛出 OSError。基本语法格式如下:</p><p>open(file, mode) # 简写语法</p><p>open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</p><blockquote><p><strong>file</strong>：一个 path-like object，表示将要打开的文件的路径。<br /> <strong>mode</strong>：打开文件的模式<br /> <strong>encoding</strong>: 一般使用utf8 ,不指定编码无法识别汉字 <strong>errors</strong>: 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。<br /> <strong>newline</strong>: 区分换行符,,默认根据平台来辨别换行符<br /> <strong>closefd</strong>: 传入的file参数类型<br /> <strong>buffering</strong>: 设置缓冲.传递0以切换缓冲关闭（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），并且&gt;1的整数以指示固定大小的块缓冲区的大小（以字节为单位）。如果没有给出 buffering 参数，则默认缓冲策略的工作方式如下:</p><blockquote><p>二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 io.DEFAULT_BUFFER_SIZE。在许多系统上，缓冲区的长度通常为4096或8192字节。 “交互式”文本文件（ isatty() 返回 True 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。</p></blockquote></blockquote><h2 id="文件打开模式">文件打开模式</h2><div class="table-wrapper"><table><thead><tr><th style="text-align: left">模式<th style="text-align: left">描述<tbody><tr><td style="text-align: left">t<td style="text-align: left">文本模式 (默认)。<tr><td style="text-align: left">x<td style="text-align: left">写模式，新建一个文件，如果该文件已存在则会报错。<tr><td style="text-align: left">b<td style="text-align: left">二进制模式。<tr><td style="text-align: left">+<td style="text-align: left">打开一个文件进行更新(可读可写)。<tr><td style="text-align: left">U<td style="text-align: left">通用换行模式（不推荐）。<tr><td style="text-align: left">r<td style="text-align: left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<tr><td style="text-align: left">rb<td style="text-align: left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。<tr><td style="text-align: left">r+<td style="text-align: left">打开一个文件用于读写。文件指针将会放在文件的开头。<tr><td style="text-align: left">rb+<td style="text-align: left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。<tr><td style="text-align: left">w<td style="text-align: left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<tr><td style="text-align: left">wb<td style="text-align: left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<tr><td style="text-align: left">w+<td style="text-align: left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<tr><td style="text-align: left">wb+<td style="text-align: left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<tr><td style="text-align: left">a<td style="text-align: left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<tr><td style="text-align: left">ab<td style="text-align: left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<tr><td style="text-align: left">a+<td style="text-align: left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<tr><td style="text-align: left">ab+<td style="text-align: left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</table></div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">模式<th style="text-align: center">r<th style="text-align: center">r+<th style="text-align: center">w<th style="text-align: center">w+<th style="text-align: center">a<th style="text-align: center">a+<tbody><tr><td style="text-align: center">读<td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center"> <td style="text-align: center">+<td style="text-align: center"> <td style="text-align: center">+<tr><td style="text-align: center">写<td style="text-align: center"> <td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center">+<tr><td style="text-align: center">创建<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center">+<tr><td style="text-align: center">覆盖<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">指针在开始<td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center">+<td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">指针在结尾<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">+<td style="text-align: center">+</table></div><p>文件打开方式1</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"/tmp/foo.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span>  <span class="c1"># 打开一个文件  
</span><span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span> <span class="s">"非常好的语言。</span><span class="se">\n</span><span class="s">是的，的确非常好!!</span><span class="se">\n</span><span class="s">"</span> <span class="p">)</span>  
<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 关闭打开的文件  
</span></pre></table></code></div></div><p>文件打开方式2</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"/tmp/foo.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="c1"># with语句块内会自动调用f.close()帮助关闭文件
</span>    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span> <span class="s">"Python 是一个非常好的语言。</span><span class="se">\n</span><span class="s">是的，的确非常好!!</span><span class="se">\n</span><span class="s">"</span> <span class="p">)</span>
</pre></table></code></div></div><h2 id="文件对象的属性">文件对象的属性</h2><div class="table-wrapper"><table><thead><tr><th style="text-align: left">属性<th style="text-align: left">描述<tbody><tr><td style="text-align: left">file.closed<td style="text-align: left">返回true如果文件已被关闭，否则返回false。<tr><td style="text-align: left">file.mode<td style="text-align: left">返回被打开文件的访问模式。<tr><td style="text-align: left">file.name<td style="text-align: left">返回文件的名称。<tr><td style="text-align: left">file.encoding<td style="text-align: left">返回文件的编码<tr><td style="text-align: left">file.newlines<td style="text-align: left">返回文件的换行符<tr><td style="text-align: left">file.line_buffering<td style="text-align: left">返回bool.是否设置了缓冲</table></div><h2 id="文件对象的方法">文件对象的方法</h2><p>f.read([,size])</p><p>- 读取一定数目的数据, 然后作为字符串或字节对象返回。默认读取整个文件.在文本模式下size指的是多少个字符,在二进制模式下是多少个字节</p><p>f.readline(size)</p><p>- 从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。如果指定size而一行未读完,再次调用readline时会接着上次的继续读取直到遇到换行符,如果指定的size大于一行数据,则读到行尾就不再继续读取</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1"># 文本
</span><span class="mi">1</span><span class="p">:</span><span class="n">www</span><span class="p">.</span><span class="n">ru</span>\<span class="n">noob</span><span class="p">.</span><span class="n">com</span>
<span class="mi">2</span><span class="p">:</span><span class="n">www</span><span class="p">.</span><span class="n">runoob</span><span class="p">.</span><span class="n">com</span>
<span class="mi">3</span><span class="p">:</span><span class="n">www</span><span class="p">.</span><span class="n">runoob</span><span class="p">.</span><span class="n">com</span>
<span class="mi">4</span><span class="p">:</span><span class="n">www</span><span class="p">.</span><span class="n">runoob</span><span class="p">.</span><span class="n">com</span>
<span class="mi">5</span><span class="p">:</span><span class="n">www</span><span class="p">.</span><span class="n">runoob</span><span class="p">.</span><span class="n">com</span>

<span class="c1"># 代码
</span><span class="n">fo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"runoob.txt"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">)</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">fo</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
<span class="k">print</span> <span class="p">(</span><span class="s">"读取第一行 %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">line</span><span class="p">))</span>  <span class="c1"># 文本中写的\n会被转义为\\\\n,不会被认为是换行符
</span><span class="n">line</span> <span class="o">=</span> <span class="n">fo</span><span class="p">.</span><span class="n">readline</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">print</span> <span class="p">(</span><span class="s">"读取的字符串为: %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">line</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">fo</span><span class="p">.</span><span class="n">readline</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">fo</span><span class="p">.</span><span class="n">readline</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="n">fo</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># 输出
</span><span class="n">读取第一行</span> <span class="mi">1</span><span class="p">:</span><span class="n">www</span><span class="p">.</span><span class="n">runoob</span><span class="p">.</span><span class="n">com</span>

<span class="n">读取的字符串为</span><span class="p">:</span> <span class="mi">2</span><span class="p">:</span><span class="n">www</span>
<span class="p">.</span><span class="n">runoob</span><span class="p">.</span><span class="n">c</span>
<span class="n">om</span>
</pre></table></code></div></div><p>f.readlines()</p><p>- 将返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</p><p>f.write(string)</p><p>- 将 string 写入到文件中, 然后返回写入的字符数</p><p>f.tell()</p><p>- 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数/字符数。</p><p>f.seek(offset, from_what)</p><p>- 如果要改变文件指针当前的位置, from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，from_what 值为默认为0，即文件开头。offset表示偏移当前指针的字节数.只对”b”模式有用,”t”模式只允许从文件头开始计算位置</p>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符<p>​ seek(x,1) ： 表示从当前位置往后移动x个字符</p><p>​ seek(-x,2)：表示从文件的结尾往前移动x个字符</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"a.txt"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf8"</span><span class="p">)</span>       
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>       
<span class="s">'zxy</span><span class="se">\n</span><span class="s">#abc'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">tell</span><span class="p">()</span>	       
<span class="mi">8</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"nihao"</span><span class="p">)</span> <span class="c1"># "nihao"被写入文件末尾       
</span><span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># seek改变指针位置之后,如果进行写操作,将会覆盖指针后边相应长度的字符/字节
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"a.txt"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf8"</span><span class="p">)</span>	       
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>	       
<span class="mi">8</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"youdu"</span><span class="p">)</span>  <span class="c1"># "youdu"从第八个字符位置覆盖五个字符写入       
</span><span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></table></code></div></div><p>f.flush()</p><p>- 将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。</p><p>一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。</p><p>f.truncate([size])</p><p>- 从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。</p><p>f.writelines(sequence)</p><p>- 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</p><p>f.close()</p><p>- 关闭文件并释放系统的资源</p><h2 id="三个标准流">三个标准流</h2><p>变量 sys.stdin 、 sys.stdout 和 sys.stderr 是类似于文件的流对象，表示标准的UNIX概念：标准输入、标准输出和标准错误。一个标准数据输入源是 sys.stdin 。当程序从标准输入读取时，你可通过输入来提供文本，也可使用管道将标准输入关联到其他程序的标准输出.你提供给 print 的文本出现在 sys.stdout 中，向 input 提供的提示信息也出现在这里。写入到 sys.stdout 的数据通常出现在屏幕上，但可使用管道将其重定向到另一个程序的标准输入。错误消息（如栈跟踪）被写入到 sys.stderr ，但与写入到 sys.stdout 的内容一样，可对其进行重定向。</p><h2 id="序列化和反序列化">序列化和反序列化</h2><p>pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p>提示：注意区分pickle.dumps()和pickle.dump(),前者操作的不是文件</p><p>提示：注意区分pickle.loads()和pickle.load(),前者操作的不是文件</p><p><strong>序列化操作</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">pickle</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span> <span class="p">[,</span><span class="n">protocol</span><span class="o">=</span><span class="bp">None</span><span class="p">])</span>
</pre></table></code></div></div><p>将序列化后的对象obj以二进制形式写入文件file中，进行保存。关于参数file，有一点需要注意，必须是以二进制的形式进行操作（写入）。file为’svm_model_iris.pkl’，并且以二进制的形式（’wb’）写入。可选参数 protocol 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 HIGHEST_PROTOCOL(4)。如果没有指定，这一参数默认值为 DEFAULT_PROTOCOL。指定一个负数就相当于指定 HIGHEST_PROTOCOL</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">pickle</span>
<span class="c1"># 使用pickle模块将数据对象保存到文件
</span><span class="n">data1</span> <span class="o">=</span> <span class="p">{</span><span class="s">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mf">6j</span><span class="p">],</span>
         <span class="s">'b'</span><span class="p">:</span> <span class="p">(</span><span class="s">'string'</span><span class="p">,</span> <span class="sa">u</span><span class="s">'Unicode string'</span><span class="p">),</span>
         <span class="s">'c'</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
<span class="n">selfref_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">selfref_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">selfref_list</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'data.pkl'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span>
<span class="c1"># Pickle dictionary using protocol 3.
</span><span class="n">pickle</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
<span class="c1"># Pickle the list using the highest protocol available.
</span><span class="n">pickle</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="n">selfref_list</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">output</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></table></code></div></div><p><strong>反序列化操作</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">pickle</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span><span class="n">fix_imports</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="err">”</span><span class="n">ASCII</span><span class="err">”</span><span class="p">.</span> <span class="n">errors</span><span class="o">=</span><span class="err">”</span><span class="n">strict</span><span class="err">”</span><span class="p">)</span>
</pre></table></code></div></div><p>该方法实现的是将序列化的对象从文件file中读取出来。关于参数file，有一点需要注意，必须是以二进制的形式进行操作（读取）。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">#使用pickle模块从文件中重构python对象
</span><span class="n">pkl_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'data.pkl'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span>

<span class="n">data1</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>

<span class="n">data2</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>

<span class="n">pkl_file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></table></code></div></div><h1 id="生成器和迭代器">生成器和迭代器</h1><h2 id="迭代器">迭代器</h2><p>可以直接作用于for循环的对象统称为<strong>可迭代对象</strong>：Iterable</p><p>可以使用isinstance()判断一个对象是否是Iterable对象</p><p>可以被next()函数调用并不断返回下一个值的对象称为<strong>迭代器</strong>：Iterator</p><p>可以使用isinstance()判断一个对象是否是Iterator对象</p><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <em>_iter</em>_() 与 <em>_next</em>_():</p><p><em>_iter</em>_() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <em>_next</em>_() 方法并通过 StopIteration 异常标识迭代的完成。</p><p><em>_next</em>_() 方法会返回下一个迭代器对象。</p><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1"># 创建一个迭代器
</span><span class="k">class</span> <span class="nc">MyNumbers</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">self</span>
 
  <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
      <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">a</span>
      <span class="bp">self</span><span class="p">.</span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="nb">StopIteration</span>
      
<span class="n">myclass</span> <span class="o">=</span> <span class="n">MyNumbers</span><span class="p">()</span>
<span class="n">myiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">myclass</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">myiter</span><span class="p">))</span>  <span class="c1"># 输出1
</span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">myiter</span><span class="p">))</span>  <span class="c1"># 输出2
</span></pre></table></code></div></div><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：iter() 和 next()。</p><p>list、dict、str虽然是Iterable，却不是Iterator。可以使用iter()函数将它们变成迭代器</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span> <span class="n">Iterator</span><span class="p">)</span>
<span class="bp">True</span>
</pre></table></code></div></div><p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><h2 id="生成器">生成器</h2><p>创建一个包含100万个元素的列表，占用很大的存储空间，生成器可以在需要用到的时候生成一个值给我们，节省空间</p><p>在 Python 中，使用了 <strong>yield</strong> 的函数被称为<strong>生成器</strong>（generator）。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><p><strong>创建生成器-方式1</strong></p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">第一种方法很简单</span><span class="err">，</span><span class="n">只要把一个列表生成式的</span><span class="p">[]</span><span class="n">改成</span><span class="p">()</span><span class="err">，</span><span class="n">就创建了一个generator</span><span class="err">：</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g</span>
<span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="o">&lt;</span><span class="n">genexpr</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x1022ef630</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="mi">0</span>
</pre></table></code></div></div><p>可以通过next()函数获得generator的下一个返回值，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。也可以用for 循环遍历</p><p><strong>创建生成器-方式2</strong></p><p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.generator的函数在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="nb">max</span><span class="p">):</span>
    <span class="s">"""斐波那契数列"""</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">b</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="s">'done'</span>
</pre></table></code></div></div><p>可以用next()调用生成器对象，也可以用for循环，用for循环调用generator时，拿不到generator的return语句的返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>  <span class="c1"># g 是一个迭代器，由生成器返回生成
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="p">...</span>     <span class="k">try</span><span class="p">:</span>
<span class="p">...</span>         <span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="p">...</span>         <span class="k">print</span><span class="p">(</span><span class="s">'g:'</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="p">...</span>     <span class="k">except</span> <span class="nb">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="p">...</span>         <span class="k">print</span><span class="p">(</span><span class="s">'Generator return value:'</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
<span class="p">...</span>         <span class="k">break</span>
</pre></table></code></div></div><p>yield关键字有两点作用：</p><ul><li>保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起<li>将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用</ul><p>Python3中的生成器可以使用return返回最终运行的返回值，而Python2中的生成器不允许使用return返回一个返回值（即可以使用return从生成器中退出，但return后不能有任何表达式）</p><p>除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
   <span class="p">....:</span>     <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="p">....:</span>     <span class="k">while</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">:</span>
   <span class="p">....:</span>         <span class="n">temp</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">i</span>
   <span class="p">....:</span>         <span class="k">print</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
   <span class="p">....:</span>         <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
   <span class="p">....:</span>
    <span class="n">In</span> <span class="p">[</span><span class="mi">43</span><span class="p">]:</span> <span class="n">f</span> <span class="o">=</span> <span class="n">gen</span><span class="p">()</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">44</span><span class="p">]:</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">44</span><span class="p">]:</span> <span class="mi">0</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">45</span><span class="p">]:</span> <span class="n">f</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">'haha'</span><span class="p">)</span>
<span class="n">haha</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">45</span><span class="p">]:</span> <span class="mi">1</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">46</span><span class="p">]:</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="bp">None</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">46</span><span class="p">]:</span> <span class="mi">2</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">47</span><span class="p">]:</span> <span class="n">f</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">'haha'</span><span class="p">)</span>
<span class="n">haha</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">47</span><span class="p">]:</span> <span class="mi">3</span>
    
<span class="n">执行到yield时</span><span class="err">，</span><span class="n">gen函数作用暂时保存</span><span class="err">，</span><span class="n">返回i的值</span><span class="p">;</span> <span class="n">temp接收下次c</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"python"</span><span class="p">)</span><span class="n">发送过来的值</span><span class="p">;</span> <span class="n">c</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span><span class="n">等价c</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>   
<span class="n">注意</span><span class="err">：</span><span class="n">send</span><span class="p">()</span><span class="n">作为生成器的起始唤醒函数时</span><span class="err">，</span><span class="n">得传一个None值</span> <span class="err">，</span><span class="n">不能传别的值</span> <span class="n">也不能不传值</span>
</pre></table></code></div></div><h2 id="forin循环的本质">for…in…循环的本质</h2><p><code class="language-plaintext highlighter-rouge">for item in Iterable</code> 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。</p><h1 id="命名空间和作用域">命名空间和作用域</h1><h2 id="三种命名空间">三种命名空间</h2><p><strong>内置名称</strong>（built-in names），Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</p><p><strong>全局名称</strong>(global names),模块中定义的名称，记录了模块的变量,包括函数、类、其它导入的模块、模块级的变量和常量。</p><p><strong>局部名称</strong>(local names),函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</p><p>命名空间查找顺序:<strong>局部的命名空间去</strong> -&gt; <strong>全局命名空间</strong> -&gt; <strong>内置命名空间</strong>。</p><p>如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1"># var1 是全局名称
</span><span class="n">var1</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">def</span> <span class="nf">some_func</span><span class="p">():</span>
 
    <span class="c1"># var2 是局部名称
</span>    <span class="n">var2</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">def</span> <span class="nf">some_inner_func</span><span class="p">():</span>
 
        <span class="c1"># var3 是内嵌的局部名称
</span>        <span class="n">var3</span> <span class="o">=</span> <span class="mi">7</span>
</pre></table></code></div></div><h2 id="四种作用域">四种作用域</h2><p>L（Local）：最内层，包含局部变量，比如一个函数/方法内部。</p><p>E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</p><p>G（Global）：当前脚本的最外层，比如当前模块的全局变量。</p><p>B（Built-in）： 包含了内建的变量/关键字等。，最后被搜索</p><p>规则顺序： L –&gt; E –&gt; G –&gt;gt; B。在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">g_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 全局作用域
</span><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="n">o_count</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 闭包函数外的函数中
</span>    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="n">i_count</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># 局部作用域
</span></pre></table></code></div></div><p>只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问</p><h2 id="全局变量和局部变量">全局变量和局部变量</h2><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 这是一个全局变量
# 可写函数说明
</span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span> <span class="p">):</span>
    <span class="c1">#返回2个参数的和."
</span>    <span class="n">total</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span> <span class="c1"># total在这里是局部变量.
</span>    <span class="k">print</span> <span class="p">(</span><span class="s">"函数内是局部变量 : "</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total</span>
 
<span class="c1">#调用sum函数
</span><span class="nb">sum</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">)</span>
<span class="k">print</span> <span class="p">(</span><span class="s">"函数外是全局变量 : "</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="global-和-nonlocal关键字">global 和 nonlocal关键字</h2><p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">fun1</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">num</span>  <span class="c1"># 需要使用 global 关键字声明
</span>    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> 
    <span class="n">num</span> <span class="o">=</span> <span class="mi">123</span>
    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="n">fun1</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">num</span>   <span class="c1"># nonlocal关键字声明
</span>        <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">inner</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="n">outer</span><span class="p">()</span>
</pre></table></code></div></div><h1 id="闭包与装饰器">闭包与装饰器</h1><h2 id="闭包">闭包</h2><p>在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。</p><h2 id="闭包的形成条件">闭包的形成条件</h2><ul><li><p>在函数嵌套(函数里面再定义函数)的前提下</p><li><p>内部函数使用了外部函数的变量(还包括外部函数的参数)</p><li><p>外部函数返回了内部函数</p></ul><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1"># 定义一个外部函数
</span><span class="k">def</span> <span class="nf">func_out</span><span class="p">(</span><span class="n">num1</span><span class="p">):</span>

    <span class="c1"># 定义一个内部函数
</span>    <span class="k">def</span> <span class="nf">func_inner</span><span class="p">(</span><span class="n">num2</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">num1</span>  <span class="c1"># 告诉解释器，此处使用的是 外部变量a
</span>        <span class="c1"># 修改外部变量num1
</span>        <span class="n">num1</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1"># 内部函数使用了外部函数的变量(num1)
</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"结果是:"</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">num1</span><span class="p">)</span>
    <span class="n">func_inner</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">num1</span><span class="p">)</span>

    <span class="c1"># 外部函数返回了内部函数，这里返回的内部函数就是闭包
</span>    <span class="k">return</span> <span class="n">func_inner</span>
</pre></table></code></div></div><h2 id="装饰器">装饰器</h2><p>就是给已有函数增加额外功能的函数，它本质上就是一个闭包函数。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1"># 装饰器的基本雏形
</span><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span> <span class="c1"># fn:目标函数.
</span>    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="s">'''执行函数之前'''</span>
        <span class="n">fn</span><span class="p">()</span> <span class="c1"># 执行被装饰的函数
</span>        <span class="s">'''执行函数之后'''</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="k">def</span> <span class="nf">myfunc</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"执行"</span><span class="p">)</span>

<span class="c1"># 使用装饰器来装饰函数
</span><span class="n">myfunc</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="n">myfunc</span><span class="p">()</span>
</pre></table></code></div></div><p>每次都需要编写func = decorator(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。简单的写法: @装饰器名字</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">@</span><span class="n">decorator</span>  <span class="c1"># 等于myfunc = decorator(myfunc)，在加载模块时就会执行装饰器
</span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"执行"</span><span class="p">)</span>
<span class="n">myfunc</span><span class="p">()</span>
</pre></table></code></div></div><h2 id="装饰带有参数的闭包函数通用">装饰带有参数的闭包函数(通用)</h2><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1"># 通用装饰器
</span><span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"--正在努力计算--"</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span>

  <span class="k">return</span> <span class="n">inner</span>
</pre></table></code></div></div><h2 id="多个装饰器的使用">多个装饰器的使用</h2><p>多个装饰器的装饰过程是，离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">make_div</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""对被装饰的函数的返回值 div标签"""</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">"&lt;div&gt;"</span> <span class="o">+</span> <span class="n">func</span><span class="p">()</span> <span class="o">+</span> <span class="s">"&lt;/div&gt;"</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="k">def</span> <span class="nf">make_p</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""对被装饰的函数的返回值 p标签"""</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">"&lt;p&gt;"</span> <span class="o">+</span> <span class="n">func</span><span class="p">()</span> <span class="o">+</span> <span class="s">"&lt;/p&gt;"</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="c1"># 装饰过程: 1 content = make_p(content) 2 content = make_div(content)
# content = make_div(make_p(content))
</span><span class="o">@</span><span class="n">make_div</span>
<span class="o">@</span><span class="n">make_p</span>
<span class="k">def</span> <span class="nf">content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"人生苦短"</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">content</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="c1"># 注意
# 执行顺序是  3，1，2，4
</span></pre></table></code></div></div><h2 id="带有参数的装饰器">带有参数的装饰器</h2><p>带有参数的装饰器就是使用装饰器装饰函数的时候可以传入指定参数，语法格式: @装饰器(参数,…)</p><p>装饰器只能接收一个参数，并且还是函数类型。</p><p>可以在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1"># 添加输出日志的功能
</span><span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s">"+"</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"--正在努力加法计算--"</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s">"-"</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"--正在努力减法计算--"</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">inner</span>

    <span class="c1"># 返回装饰器
</span>    <span class="k">return</span> <span class="n">decorator</span>


<span class="c1"># 使用装饰器装饰函数
</span><span class="o">@</span><span class="n">logging</span><span class="p">(</span><span class="s">"+"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></table></code></div></div><h2 id="类装饰器">类装饰器</h2><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Check</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="c1"># 初始化操作在此完成
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">__fn</span> <span class="o">=</span> <span class="n">fn</span>

    <span class="c1"># 实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。
</span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># 添加装饰功能
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"请先登陆..."</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__fn</span><span class="p">()</span>

<span class="o">@</span><span class="n">Check</span>
<span class="k">def</span> <span class="nf">comment</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"发表评论"</span><span class="p">)</span>

<span class="n">comment</span><span class="p">()</span>
</pre></table></code></div></div><p>@Check 等价于 comment = Check(comment), 所以需要提供一个init方法，并多增加一个fn参数。</p><p>要想类的实例对象能够像函数一样调用，需要在类里面使用__call__方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。</p><p>在__call__方法里进行对fn函数的装饰，可以添加额外的功能。</p><h1 id="property属性">property属性</h1><p>Python内置的@property装饰器就是负责把一个方法变成属性调用</p><p>property属性的定义和调用要注意一下几点：</p><p>定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数</p><p>调用时，无需括号</p><p>两种方式：</p><p>装饰器 即：在方法上应用装饰器</p><p>类属性 即：在类中定义值为property对象的类属性</p><h2 id="装饰器方式">装饰器方式</h2><p>在类的实例方法上应用@property装饰器</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Goods</span><span class="p">:</span>
    <span class="s">"""python3中默认继承object类
        以python2、3执行此程序的结果不同，因为只有在python3中才有@xxx.setter  @xxx.deleter
    """</span>
    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'@property'</span><span class="p">)</span>

    <span class="o">@</span><span class="n">price</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'@price.setter'</span><span class="p">)</span>

    <span class="o">@</span><span class="n">price</span><span class="p">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'@price.deleter'</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Goods</span><span class="p">()</span>
<span class="n">obj</span><span class="p">.</span><span class="n">price</span>          <span class="c1"># 自动执行 @property 修饰的 price 方法，并获取方法的返回值
</span><span class="n">obj</span><span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="mi">123</span>    <span class="c1"># 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数
</span><span class="k">del</span> <span class="n">obj</span><span class="p">.</span><span class="n">price</span>      <span class="c1"># 自动执行 @price.deleter 修饰的 price 方法
</span></pre></table></code></div></div><p>经典类中的属性只有一种访问方式，其对应被 @property 修饰的方法 新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法</p><h2 id="类属性方式">类属性方式</h2><p>创建值为property对象的类属性，当使用类属性的方式创建property属性时，经典类和新式类无区别</p><p>property方法中有个四个参数</p><p>第一个参数是方法名，调用 对象.属性 时自动触发执行方法</p><p>第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法</p><p>第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法</p><p>第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">#coding=utf-8
</span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"getter..."</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">'laowang'</span>

    <span class="k">def</span> <span class="nf">set_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> 
        <span class="s">"""必须两个参数"""</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"setter..."</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">'set value'</span> <span class="o">+</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">del_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"deleter..."</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">'laowang'</span>

    <span class="n">BAR</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_bar</span><span class="p">,</span> <span class="n">set_bar</span><span class="p">,</span> <span class="n">del_bar</span><span class="p">,</span> <span class="s">"description..."</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">obj</span><span class="p">.</span><span class="n">BAR</span>  <span class="c1"># 自动调用第一个参数中定义的方法：get_bar
</span><span class="n">obj</span><span class="p">.</span><span class="n">BAR</span> <span class="o">=</span> <span class="s">"alex"</span>  <span class="c1"># 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入
</span><span class="n">desc</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">.</span><span class="n">BAR</span><span class="p">.</span><span class="n">__doc__</span>  <span class="c1"># 自动获取第四个参数中设置的值：description...
</span><span class="k">print</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
<span class="k">del</span> <span class="n">obj</span><span class="p">.</span><span class="n">BAR</span>  <span class="c1"># 自动调用第三个参数中定义的方法：del_bar方法
</span></pre></table></code></div></div><p>property 其实并不是函数，而是一个类。它的实例包含一些魔法方法，而所有的魔法都</p><p>是由这些方法完成的。这些魔法方法为 __get__ 、 __set__ 和 __delete__ ，它们一道定义了所谓</p><p>的描述符协议。只要对象实现了这些方法中的任何一个，它就是一个描述符。描述符的独特</p><p>之处在于其访问方式。例如，读取属性（具体来说，是在实例中访问类中定义的属性）时，如</p><p>果它关联的是一个实现了 __get__ 的对象，将不会返回这个对象，而是调用方法 __get__ 并将</p><p>其结果返回。</p><h1 id="魔法方法">魔法方法</h1><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre><td class="rouge-code"><pre><span class="mf">1.</span> <span class="n">__doc__</span>
<span class="n">表示类的描述信息</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="s">""" 描述类信息，这是用于看片的神奇 """</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">.</span><span class="n">__doc__</span><span class="p">)</span>
<span class="c1">#输出：类的描述信息
</span>
<span class="mf">2.</span> <span class="n">__module__</span> <span class="n">和</span> <span class="n">__class__</span>
<span class="n">__module__</span> <span class="n">表示当前操作的对象在那个模块</span>
<span class="n">__class__</span> <span class="n">表示当前操作的对象的类是什么</span>
<span class="n">test</span><span class="p">.</span><span class="n">py</span>

<span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">'laowang'</span>

<span class="mf">5.</span> <span class="n">__call__</span>
<span class="n">对象后面加括号</span><span class="err">，</span><span class="n">触发执行</span><span class="err">。</span>
<span class="n">注</span><span class="err">：</span><span class="n">__init__方法的执行是由创建对象触发的</span><span class="err">，</span><span class="n">即</span><span class="err">：</span><span class="n">对象</span> <span class="o">=</span> <span class="n">类名</span><span class="p">()</span> <span class="err">；</span><span class="n">而对于</span> <span class="n">__call__</span> <span class="n">方法的执行是由对象后加括号触发的</span><span class="err">，</span><span class="n">即</span><span class="err">：</span><span class="n">对象</span><span class="p">()</span> <span class="n">或者</span> <span class="n">类</span><span class="p">()()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'__call__'</span><span class="p">)</span>


<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>  <span class="c1"># 执行 __init__
</span><span class="n">obj</span><span class="p">()</span>  <span class="c1"># 执行 __call__
</span>
<span class="mf">6.</span><span class="n">__getitem__</span><span class="err">、</span><span class="n">__setitem__</span><span class="err">、</span><span class="n">__delitem__</span>
<span class="n">用于索引操作</span><span class="err">，</span><span class="n">如字典</span><span class="err">。</span><span class="n">以上分别表示获取</span><span class="err">、</span><span class="n">设置</span><span class="err">、</span><span class="n">删除数据</span>
<span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'__getitem__'</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'__setitem__'</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'__delitem__'</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>


<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s">'k1'</span><span class="p">]</span>      <span class="c1"># 自动触发执行 __getitem__
</span><span class="n">obj</span><span class="p">[</span><span class="s">'k2'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'laowang'</span>   <span class="c1"># 自动触发执行 __setitem__
</span><span class="k">del</span> <span class="n">obj</span><span class="p">[</span><span class="s">'k1'</span><span class="p">]</span>           <span class="c1"># 自动触发执行 __delitem__
</span>
<span class="mf">7.</span><span class="n">__getslice__</span><span class="err">、</span><span class="n">__setslice__</span><span class="err">、</span><span class="n">__delslice__</span>
<span class="n">该三个方法用于分片操作</span><span class="err">，</span><span class="n">如</span><span class="err">：</span><span class="n">列表</span>
<span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'__getslice__'</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'__setslice__'</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'__delslice__'</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">obj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># 自动触发执行 __getslice__
</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">44</span><span class="p">]</span>    <span class="c1"># 自动触发执行 __setslice__
</span><span class="k">del</span> <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                <span class="c1"># 自动触发执行 __delslice__
</span>
<span class="mf">8.</span><span class="n">__str__</span>
<span class="n">该方法需要</span> <span class="k">return</span> <span class="n">一个数据</span><span class="err">，</span><span class="n">并且只有self一个参数</span><span class="err">，</span><span class="n">当在类的外部</span> <span class="k">print</span><span class="p">(</span><span class="n">对象</span><span class="p">)</span> <span class="n">则打印这个数据</span><span class="p">;</span><span class="n">如果没有定义该方法</span><span class="p">,</span><span class="n">则默认打印对象的内存地址</span>

<span class="mf">9.</span><span class="n">__del__</span><span class="p">()</span>
<span class="n">当删除对象时</span><span class="err">，</span><span class="n">python解释器会默认调用__del__</span><span class="p">()</span><span class="n">方法</span>
</pre></table></code></div></div><h1 id="with与上下文管理器">with与上下文管理器</h1><p>对于系统资源如文件、数据库连接、socket 而言，应用程序打开这些资源并执行完业务逻辑之后，必须做的一件事就是要关闭（断开）该资源。</p><p><strong>上下文管理器</strong></p><p>任何实现了 __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。__enter__() 方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__() 方法处理一些清除工作。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">File</span><span class="p">():</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"entering"</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">f</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"will exit"</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># 调用
</span><span class="k">with</span> <span class="n">File</span><span class="p">(</span><span class="s">'out.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"writing"</span><span class="p">)</span>
    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">'hello, python'</span><span class="p">)</span> 
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">__enter__</code>表示上文方法，需要返回一个操作文件对象<li><code class="language-plaintext highlighter-rouge">__exit__</code>表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法</ul><p>Python 提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 之前的语句在 __enter__ 方法中执行，yield 之后的语句在 __exit__ 方法中执行。紧跟在 yield 后面的值是函数的返回值。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="o">@</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">my_open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">f</span>
    <span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>   

<span class="c1"># 调用
</span><span class="k">with</span> <span class="n">my_open</span><span class="p">(</span><span class="s">'out.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"hello , the simplest context manager"</span><span class="p">)</span> 
</pre></table></code></div></div><h1 id="元类">元类</h1><p>元类就是用来创建类的类。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段，但是，Python中的类还远不止如此。类同样也是一种对象。当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。它是创建类对象的</p><h2 id="使用type创建类">使用type创建类</h2><p>type还有一种完全不同的功能，动态的创建类。</p><p>type可以接受一个类的描述作为参数，然后返回一个类。（要知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）</p><p>type可以像这样工作：</p><p>type(类名, 由父类名称组成的元组(针对继承的情况，可以为空)，包含属性的字典(名称和值))</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1"># 示例
</span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span>

<span class="k">def</span> <span class="nf">print_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="s">"""准备的实例方法"""</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>

<span class="o">@</span><span class="nb">staticmethod</span>
<span class="k">def</span> <span class="nf">print_static</span><span class="p">():</span>
    <span class="s">"""准备的静态方法"""</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"----haha-----"</span><span class="p">)</span>

<span class="o">@</span><span class="nb">classmethod</span>
<span class="k">def</span> <span class="nf">print_class</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="s">"""准备的类方法"""</span>
    <span class="k">print</span><span class="p">(</span><span class="n">cls</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>

<span class="c1"># 如果添加属性，那么加的都是类属性
</span><span class="n">B</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">"B"</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,),</span> <span class="p">{</span><span class="s">"print_b"</span><span class="p">:</span> <span class="n">print_b</span><span class="p">,</span> <span class="s">"print_static"</span><span class="p">:</span> <span class="n">print_static</span><span class="p">,</span> <span class="s">"print_class"</span><span class="p">:</span> <span class="n">print_class</span><span class="p">})</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="n">b</span><span class="p">.</span><span class="n">print_b</span><span class="p">()</span>
<span class="n">b</span><span class="p">.</span><span class="n">print_static</span><span class="p">()</span>
<span class="n">b</span><span class="p">.</span><span class="n">print_class</span><span class="p">()</span>
<span class="c1"># 结果
# 100
# ----haha-----
# 100
</span></pre></table></code></div></div><p>元类就是用来创建类的“东西”。元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">MyClass</span> <span class="o">=</span> <span class="n">MetaClass</span><span class="p">()</span> <span class="c1"># 使用元类创建出一个对象，这个对象称为“类”
</span><span class="n">my_object</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span> <span class="c1"># 使用“类”来创建出实例对象
</span></pre></table></code></div></div><p>函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来，这个类就是type。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">35</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">age</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="s">'int'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="s">'type'</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">__class__</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="p">.</span><span class="n">Bar</span><span class="s">'&gt;
&gt;&gt;&gt; b.__class__.__class__
&lt;type '</span><span class="nb">type</span><span class="s">'&gt;
</span></pre></table></code></div></div><h2 id="__metaclass__属性">__metaclass__属性</h2><p>也可以创建自己的元类，在定义一个类的时候为其添加__metaclass__属性。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Bar</span><span class="p">):</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">something</span><span class="err">…</span>
    <span class="p">...</span><span class="n">省略</span><span class="p">...</span>
</pre></table></code></div></div><p>Python做了如下的操作：</p><ul><li><p>Foo中有__metaclass__这个属性吗？如果是，Python会通过__metaclass__创建一个名字为Foo的类(对象)</p><li><p>如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。</p><li><p>如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。</p><li><p>如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。</p></ul><p>现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。</p><h2 id="自定义元类">自定义元类</h2><p>元类的主要目的就是为了当创建类时能够自动地改变类,假设模块里所有的类的属性都应该是大写形式，案例如下，</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UpperAttrMetaClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="c1"># __new__ 是在__init__之前被调用的特殊方法
</span>    <span class="c1"># __new__是用来创建对象并返回之的方法
</span>    <span class="c1"># 而__init__只是用来将传入的参数初始化给对象
</span>    <span class="c1"># 你很少用到__new__，除非你希望能够控制对象的创建
</span>    <span class="c1"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__
</span>    <span class="c1"># 如果你希望的话，你也可以在__init__中做些事情
</span>    <span class="c1"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用
</span>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">class_parents</span><span class="p">,</span> <span class="n">class_attr</span><span class="p">):</span>
        <span class="c1"># 遍历属性字典，把不是__开头的属性名字变为大写
</span>        <span class="n">new_attr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">class_attr</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">"__"</span><span class="p">):</span>
                <span class="n">new_attr</span><span class="p">[</span><span class="n">name</span><span class="p">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># 方法1：通过'type'来做类对象的创建
</span>        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">class_parents</span><span class="p">,</span> <span class="n">new_attr</span><span class="p">)</span>

        <span class="c1"># 方法2：复用type.__new__方法
</span>        <span class="c1"># 这就是基本的OOP编程，没什么魔法
</span>        <span class="c1"># return type.__new__(cls, class_name, class_parents, new_attr)
</span>
<span class="c1"># python3的用法
</span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">UpperAttrMetaClass</span><span class="p">):</span>
    <span class="n">bar</span> <span class="o">=</span> <span class="s">'bip'</span>

<span class="c1"># python2的用法
# class Foo(object):
#     __metaclass__ = UpperAttrMetaClass
#     bar = 'bip'
</span>

<span class="k">print</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="s">'bar'</span><span class="p">))</span>
<span class="c1"># 输出: False
</span><span class="k">print</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="s">'BAR'</span><span class="p">))</span>
<span class="c1"># 输出:True
</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">BAR</span><span class="p">)</span>
<span class="c1"># 输出:'bip'
</span></pre></table></code></div></div><h1 id="pep8">PEP8</h1><p>PEP8 提供了 Python 代码的编写约定. 本节知识点旨在提高代码的可读性, 并使其在各种 Python 代码中编写风格保持一致.</p><ol><li><p>缩进使用4个空格, 空格是首选的缩进方式. Python3 不允许混合使用制表符和空格来缩进.</p><li><p>每一行最大长度限制在79个字符以内.</p><li><p>顶层函数、类的定义, 前后使用两个空行隔开.</p><li><p>import 导入</p><ul><li>导入建议在不同的行, 例如:</ul><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre> <span class="kn">import</span> <span class="nn">os</span>
 <span class="kn">import</span> <span class="nn">sys</span>
 <span class="c1"># 不建议如下导包
</span> <span class="kn">import</span> <span class="nn">os</span><span class="p">,</span> <span class="n">sys</span>
 <span class="c1"># 但是可以如下:
</span> <span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
</pre></table></code></div></div><ul><li><p>导包位于文件顶部, 在模块注释、文档字符串之后, 全局变量、常量之前. 导入按照以下顺序分组:</p><p>​ 标准库导入</p><p>​ 相关第三方导入</p><p>​ 本地应用/库导入</p><p>​ 在每一组导入之间加入空行</p></ul><li><p>Python 中定义字符串使用双引号、单引号是相同的, 尽量保持使用同一方式定义字符串. 当一个字符串包含单引号或者双引号时, 在最外层使用不同的符号来避免使用反斜杠转义, 从而提高可读性.</p><li><p>表达式和语句中的空格:</p><ol><li>避免在小括号、方括号、花括号后跟空格.<li>避免在逗号、分好、冒号之前添加空格.<li>冒号在切片中就像二元运算符, 两边要有相同数量的空格. 如果某个切片参数省略, 空格也省略.<li>避免为了和另外一个赋值语句对齐, 在赋值运算符附加多个空格.<li>避免在表达式尾部添加空格, 因为尾部空格通常看不见, 会产生混乱.<li>总是在二元运算符两边加一个空格, 赋值（=），增量赋值（+=，-=），比较（==,&lt;,&gt;,!=,&lt;&gt;,&lt;=,&gt;=,in,not,in,is,is not），布尔（and, or, not</ol><li><p>避免将小的代码块和 if/for/while 放在同一行, 要避免代码行太长.</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="s">'blah'</span><span class="p">:</span> <span class="n">do_blah_thing</span><span class="p">()</span>
 <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span>
 <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="n">t</span> <span class="o">=</span> <span class="n">delay</span><span class="p">()</span>
</pre></table></code></div></div><li><p>永远不要使用字母 ‘l’(小写的L), ‘O’(大写的O), 或者 ‘I’(大写的I) 作为单字符变量名. 在有些字体里, 这些字符无法和数字0和1区分, 如果想用 ‘l’, 用 ‘L’ 代替.</p><li><p>类名一般使用首字母大写的约定.</p><li><p>函数名应该小写, 如果想提高可读性可以用下划线分隔.</p><li><p>如果函数的参数名和已有的关键词冲突, 在最后加单一下划线比缩写或随意拼写更好. 因此 class_ 比 clss 更好.(也许最好用同义词来避免这种冲突).</p><li><p>方法名和实例变量使用下划线分割的小写单词, 以提高可读性.</p></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/python/'>Python</a>, <a href='/categories/python%E5%9F%BA%E7%A1%80/'>Python基础</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/python%E5%9F%BA%E7%A1%80/" class="post-tag no-text-decoration" >Python基础</a> <a href="/tags/python%E8%BF%9B%E9%98%B6/" class="post-tag no-text-decoration" >Python进阶</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Python笔记 - 图样图森破&url=https://justzxy.cn/posts/python-base/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Python笔记 - 图样图森破&u=https://justzxy.cn/posts/python-base/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Python笔记 - 图样图森破&url=https://justzxy.cn/posts/python-base/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/js/">JavaScript基础整理</a><li><a href="/posts/http-code/">HTTP 响应码</a><li><a href="/posts/pip/">python包管理工具pip</a><li><a href="/posts/pyecharts-pie/">pyecharts饼图使用笔记</a><li><a href="/posts/redis-fast/">Redis为什么这么快</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python%E6%A0%87%E5%87%86%E5%BA%93/">Python标准库</a> <a class="post-tag" href="/tags/web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">Web开发技术</a> <a class="post-tag" href="/tags/python%E8%BF%9B%E9%98%B6/">Python进阶</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> <a class="post-tag" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E7%A1%80/">Python基础</a> <a class="post-tag" href="/tags/redis/">Redis</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/meta-class/"><div class="card-body"> <span class="timeago small" > Mar 9, 2018 <i class="unloaded">2018-03-09T18:57:32+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>元类</h3><div class="text-muted small"><p> 使用type创建类 type还有一种完全不同的功能，动态的创建类。 type可以接受一个类的描述作为参数，然后返回一个类。（要知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性） type可以像这样工作： type(类名, 由父类名称组成的元组(针对继承的情况，可以为空)，包含属性的字典(名称和值)) # 示例 cl...</p></div></div></a></div><div class="card"> <a href="/posts/build-in-type/"><div class="card-body"> <span class="timeago small" > Jul 29, 2018 <i class="unloaded">2018-07-29T20:06:11+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>内置数据类型常用方法</h3><div class="text-muted small"><p> 列表 List aList.append(obj) 在列表末尾追加元素，等同于 aList[len(aList）:len(aList)] = [obj] aList.clear() 删除 aList 的所有元素 aList.count(obj) 返回 aList 中与 obj 相等的元素个数 aList.copy() 返回 aList 的副本。请注意，这是浅复制，即不会复制元素 a...</p></div></div></a></div><div class="card"> <a href="/posts/built-in-function/"><div class="card-body"> <span class="timeago small" > Sep 25, 2018 <i class="unloaded">2018-09-25T22:16:07+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>python3内置函数</h3><div class="text-muted small"><p> abs(number) 返回数字的绝对值 all(iterable) 如果 iterable 的所有元素都为真值，就返回 True ；否则返回 False any(iterable) 如果 iterable 的所有元素都为假值，就返回 False ；否则返回 True ascii(object) ascii() 函数类似 repr() 函数, 返回一个表示对象的字符串, 但是对于字符串...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/property/" class="btn btn-outline-primary" prompt="Older"><p>property属性</p></a> <a href="/posts/computer-science/" class="btn btn-outline-primary" prompt="Newer"><p>计算机工作原理概述</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 tooYoungtooSimple. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python%E6%A0%87%E5%87%86%E5%BA%93/">Python标准库</a> <a class="post-tag" href="/tags/web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">Web开发技术</a> <a class="post-tag" href="/tags/python%E8%BF%9B%E9%98%B6/">Python进阶</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> <a class="post-tag" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E7%A1%80/">Python基础</a> <a class="post-tag" href="/tags/redis/">Redis</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://justzxy.cn{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
