---
layout: post
title: 整数-小数-负数的存储
Author: TheronZhao
tags: 计算机科学
---
## 目录
- zzz
{:toc}
##  计算机中整数的存储  ##

用几个字节来表示一个整数？  byte型1字节  short型2字节  int型4字节  long型8字节

### 不带符号的整数(0和正数)

byte型1字节  0000 0000  表示的整数0 ~ 255  
short型2字节 0000 0000 0000 0000  表示整数0 ~ 65535  
int型4字节   0000 0000 0000 0000 0000 0000 0000 0000   表示整数0 ~ 4,294,967,295  
long型8字节  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 表示整数0 ~ (2^64-1)  

### 带符号的整数(负数，0，正数)

byte型1字节  0000 0000  表示的整数0 ~ 127；1000 0000  表示-1 ~ -128  
其他同上 

### 负数在计算机中的表示

	在最高位拿出来当作符号位，0表示正数，1表示负数。
	除了最高位的符号位，其他位使用的是补码的形式存储的。

计算一个数值的二进制补码，以下3个步骤：  

- 1.求这个值的绝对值的二进制原码  
- 2.原码取反，得到反码  
- 3.反码加1，即是补码  

```python
一般一个int类型整数用4字节表示,有32位
原码：   
-18  -->绝对值18	-->  0b10010  -->  0000 0000 0000 0000 0000 0000 0001 0010
反码：
1111 1111 1111 1111 1111 1111 1110 1101
补码：
1111 1111 1111 1111 1111 1111 1110 1110
```

##  计算机中小数的存储  ##

### IEEE754标准

在IEEE754标准中，一个规格化的32位浮点数x的真值表示为:  
0 00000000 00000000000000000000000  
    第0-22位，尾数，隐藏了最高位1；实际尾数是24位，尾数真值 = 1 + 尾数  
    第23-30位，阶码，阶码 = 阶码真值+127，阶码真值说白了就是幂次  
    第31位，符号位，0表示正数，1表示负数  

x = （-1）^s X 2^（E-127）X（1.M）  
    s  值为0或1  
    E = e + 127，e是阶码真值(说白了就是幂次)  
    M = 尾数真值 - 1   

float：1bit（符号位） 8bits（指数位） 23bits（尾数位）  
double：1bit（符号位） 11bits（指数位） 52bits（尾数位）  

### 小数123.567在二进制中的表示

首先整数123   1111011

小数部分  0.567  在正数中的二进制是除以2取余数，倒写；在小数中则是乘以2，满1则进一，没满就补0  

```python
0.567 * 2 = 1.134 …… 取1，基数 = 0.134  取1相当于1*2^(-1)
0.134 * 2 = 0.268 …… 取0，基数 = 0.268  取0相当于0*2^(-2)
0.268 * 2 = 0.563 …… 取0，基数 = 0.563  取0相当于0*2^(-3)
0.563 * 2 = 1.126 …… 取1，基数 = 0.126  取1相当于1*2^(-4)
…… ……
…… ……
…… ……
```

最终结果为 10010001001001101110100 （23位）

所以123.567二进制表示为1111011.10010001001001101110100  
科学计数法表示为  1.11101110010001001001101110100 * 2^6  

接下来是转换规则  由三部分构成：

```python
第一部分占用一个位，用来表示整个值的正负
    123.567是正数，第一位是0

第二部分占用m位，会使用科学计数法中的幂次
    6是幂次，6+127=133    --> 单精度二进制表示10000101 (为什么加127?因为IEEE754标准里边这样算的)
           ，6+1023=1029 --> 双精度二进制表示10000000101(为什么加1029?同上)

第三部分占用n位，会使用科学计数法中小数点后的n位
11101110010001001001101110100，小数点前边的1是永远存在的，所以没要1
```

最后组合到一起,浮点数123.567二进制表示为：  
    单精度 0 1000 0101 1110 1110 0100 0100 1001 101 110100  
    双精度 0 1000 0000 101  1110 1110 0100 0100 1001 1011 1010 0000 0000 0000 0000 0000 0000  

单精度 用32位存储   
    0 1000 0101 1110 1110 0100 0100 1001 101 (猜测：去掉了尾部的110100，所以导致运算精度的问题)  
双精度 用64位存储  
    0 1000 0000 101  1110 1110 0100 0100 1001 1011 1010 0000 0000 0000 0000 0000 0000  

### 小数数值范围问题

**float和double的范围是由指数的位数来决定的**  
于是，float的指数范围为-126~+127，而double的指数范围为-1022~+1023，并且指数位是按补码的形式来划分的。其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。  
float的范围为-2^127 ~ +2^127，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1023 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308。  

**精度问题**  
float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。  
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；  
double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。

##  Decimal精确的小数计算  ##
Decimal用来精确的表示小数，应用场景：金融交易
原理：把小数转换成整数，再记录小数点的位置
123.45   --  12345 3
```python
>>> d1 = Decimal("123.45")
>>> d1
>>> Decimal("123.45")  # 调用了__repr__，返回的是字符串
>>> print(d1)
>>> 123.45  # 调用了__str__，内部将123.45转成了12345，并记录了小数点位置dotplace
```
Decimal支持和整数的运算，和Decimal的运算，但是不支持和浮点数的运算