---
layout: post
title: Python中的赋值_引用_拷贝_传参
Author: TheronZhao
tags: Python
---
## 目录
- mulu
{:toc}

## 1.赋值 VS 引用

我们都知道Python的赋值运算符是“=”，如：

```python
>>> a = 1
>>> b = a
>>> b
>>> 1
>>> id(a)
>>> 10432856
>>> id(b)
>>> 10432856
```

id函数可以获得对象的内存地址。很明显从上面例子可以看出，将a变量作为参数赋值给了b变量，传递了a的一个引用，把a的地址传递过去了，所以变量b的地址跟变量a的地址是一样的。

下面我们看第一个案例:

```python
>>> c = [1, 2]
>>> d = c
>>> d
>>> [1, 2]
>>> id(c)
>>> 140594779781384
>>> id(d)
>>> 140594779781384
>>> d.append(3)
>>> d
>>> [1, 2, 3]
>>> c
>>> [1, 2, 3]
>>> id(c)
>>> 140594779781384
>>> id(d)
>>> 140594779781384
```

将一个可变类型的对象--列表[1, 2]赋值给变量c,再将变量c赋值给变量d，传递了c的引用，c和d同时指向一个内存地址，通过d把内存地址的对象[1, 2]变为[1, 2, 3]，变量c的值也相应改变了。

所以，**在 Python中赋值语句总是建立对象的引用值，而不是复制对象**。因此，**Python 变量更像是指针，而不是数据存储区域**。

## 2.引用 VS 拷贝

先来看下面这个案例:

```python
>>> values = [0, 1, 2]
>>> id(values)
>>> 140594779905776
>>> values[1] = values
>>> values
```

吃过之前的亏之后，我们自然而然的会认为 values 会变成 [0, [0, 1, 2], 2] ，然而结果如下：

```python
>>> values
>>> [0, [...], 2]
>>> id(values)
>>> 140594779905776
```

结果赋值无限次？

之前我们已经说过，**Python 没有赋值，只有引用**。“ L[1] = L ” 相当于创建了一个引用自身的结构，所以导致了无限循环。为了理解这个问题，有个基本概念需要搞清楚。

**Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用。**

执行 “values = [0, 1, 2]” 的时候，Python 做的事情是首先创建一个列表对象 [0, 1, 2]，然后给它贴上名为 values 的标签。如果随后又执行 “values = [3, 4, 5]” 的话，Python 做的事情是创建另一个列表对象 [3, 4, 5]，然后把刚才那张名为 values 的标签从前面的 [0, 1, 2] 对象上撕下来，重新贴到 [3, 4, 5] 这个对象上。

至始至终，并没有一个叫做 values 的列表对象容器存在，Python 也没有把任何对象的值复制进 values 去。过程如下图所示：

![](/refer/赋值拷贝引用1.jpg)

执行 “values[1] = values” 的时候，Python 做的事情则是把 values 这个标签所引用的列表对象的第二个元素指向 values 所引用的列表对象本身。执行完毕后，values 标签还是指向原来那个对象，只不过那个对象的结构发生了变化，从之前的列表 [0, 1, 2] 变成了 [0, ?, 2]，而这个 ? 则是指向那个对象本身的一个引用。如下图所示：

![](/refer/赋值拷贝引用2.jpg)

要达到我们之前所期望的的效果，即得到 [0, [0, 1, 2], 2] 这个对象，我们不能直接将 values[1] 指向 values 引用的对象本身，而是需要吧 [0, 1, 2] 这个对象「复制」一遍，得到一个新对象，再将 values[1] 指向这个复制后的对象。Python 里面复制对象的操作因对象类型而异，复制列表 values 的操作是values[:] （生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制）

所以我们需要执行如下操作：

```python
>>> values = [0, 1, 2]
>>> id(values)
>>> 140594779951256
>>> values[1] = values[:]
>>> values
>>> [0, [0, 1, 2], 2]
>>> id(values)
>>> 140594779951256
```

Python 做的事情是，先 通过引用得到 values 所指向的对象[0, 1, 2]，然后执行 \[0, 1, 2\][:] 复制操作得到一个新的对象，内容也是 [0, 1, 2]，然后将 values 所指向的列表对象的第二个元素指向这个复制而来的列表对象，最终 values 指向的对象是 [0, [0, 1, 2], 2]。过程如下图所示：

![](/refer/赋值拷贝引用3.jpg)


但是，当列表对象有嵌套的时候会产生新的问题，比如：

```python
>>> a = [0, [1, 2], 3]
>>> b = a[:]
>>> a[0] = 4
>>> a[1][1] = 5
```

此时 a 和 b 分别是多少？

```python
>>> a
>>> [4, [1, 5], 3]
>>> b
>>> [0, [1, 5], 3]
```

b 的第二个元素也被改变了！

其实，往更深处说，values[:] 复制操作是所谓的「**浅拷贝**」(shallow copy)，过程如下图所示：

![](/refer/赋值拷贝引用4.jpg)

正确的复制嵌套元素的方法是进行「**深拷贝**」(deep copy)，方法是：

```python
>>> import copy
>>> a = [0, [1, 2], 3]
>>> b = copy.deepcopy(a)
>>> a[0] = 4
>>> a[1][1] = 5
>>> a
>>> [4, [1, 5], 3]
>>> b
>>> [0, [1, 2], 3]
```

**结论**

1. 没有限制条件的切片表达式（ L[:] ）能够复制序列，但此法只能浅拷贝；

2. 有些内置函数，例如 list，能够生成拷贝 list(L)；

3. copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy ；

4. 与列表相同，字典也有 copy 方法，Dict.copy() 为浅拷贝，copy.deepcopy( Dict )则是深拷贝；

对于不可变对象和可变对象来说，浅拷贝都是复制的引用，只是因为复制不变对象和复制不变对象的引用是等效的（因为对象不可变，当改变时会新建对象重新赋值）。所以看起来浅拷贝只复制不可变对象（整数，实数，字符串等），对于可变对象，浅拷贝其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了另一个标签而已。

## 3.赋值 VS 增强赋值

我们来看下面的案例：

```python
>>> A = [1, 2]
>>> B = A
>>> A += [3, 4]
>>> A
>>> [1, 2, 3, 4]
>>> B
>>> [1, 2, 3, 4]


>>> A = [1, 2]
>>> B = A
>>> A = A + [3, 4]
>>> A
>>> [1, 2, 3, 4]
>>> B
>>> [1, 2]
```

**赋值语句 x = x + y，会新建对象 x，然后复制两个列表合并，属于复制/拷贝；**

**增强赋值语句 x += y，不生成新对象，只在内存块末尾增加元素。**

当 x、y 为list时， += 会自动调用 extend 方法进行合并运算，属于共享引用。

## 4.参数传递

函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：**值传递**和**引用传递**。

**值传递**（pass-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。

**引用传递**(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

在python中实际又是怎么样的呢？

### 4.1可变类型 VS 不可变类型

在Python中，对象分为两种：可变类型和不可变类型，不可变类型的对象包括int，float，long，str，tuple等，可变类型的对象包括list，set，dict等。需要注意的是：这里说的不可变指的是值的不可变。对于不可变类型的变量，如果要更改变量，则会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收。另外，不可变的类型可以计算hash值，作为字典的key。可变类型数据对对象操作的时候，不需要再在其它地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变。

```python
>>> def func_int(a_int):
>>> ...     a_int += 4
>>> ... 
>>> def func_list(a_list):
>>> ...     a_list[0] = 4
>>> ... 
>>> b_int = 0
>>> func_int(b_int)
>>> b_int
>>> 0
>>> b_list = [1, 2, 3]
>>> func_list(b_list)
>>> b_list
>>> [4, 2, 3]
```

对于上面的输出，不少Python初学者都比较疑惑：第一个例子看起来像是传值，而第二个例子却是传引用。其实，解释这个问题也非常容易，主要是因为可变类型参数和不可变类型参数的原因：对于可变类型参数，对象的操作不会重建对象，而对于不可变类型参数，每一次操作就重建新的对象。

在函数参数传递的时候，Python其实就是把参数里传入的变量对应的对象的引用依次赋值给对应的函数内部变量。参照上面的例子来说明更容易理解，func_int 中的局部变量 "a_int" 其实是全局变量 "b_int" 所指向对象的另一个引用，由于整数对象是不可变的，所以当 func_int 对变量 "a_int" 进行修改的时候，实际上是将局部变量 "a_int" 指向到了整数对象 "4" 。所以很明显，func_list 修改的是一个可变的对象，局部变量 "a_list" 和全局变量 "b_list" 指向的还是同一个对象。

### 4.2局部变量 VS 全局变量

我们先来看下面这个例子：

```python
>>> a = 'abc'
>>> b = [1, 2, 3]
>>> def func():
>>> ...     a = 'def'
>>> ...     b[0] = 4
>>> ... 
>>> func()
>>> a
>>> 'abc'
>>> b
>>> [4, 2, 3]
```

我们知道变量 “a” 没有改变是因为 “a” 在函数中是局部变量，如果要修改全局变量 “a” 需要用到关键字 ”global“ ，为什么修改字列表 ”b“ 的值不用global关键字先声明呢？

这是因为，在 a = 'def' 这句中，它是“有歧义的“，因为它既可以是表示引用全局变量 ”a" ，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global，global定义的本地变量会变成其对应全局变量的一个别名，即是同一个变量。

在 b[0] = 4 这句中，它是“明确的”，因为如果把 "b" 当作是局部变量的话，它会报KeyError，所以它只能是引用全局的 "b" ,故不需要多此一举显式声明global。

但如果是下面：

```python
>>> c = [1, 2]
>>> def func2():
>>> ...     c = [3, 4]
>>> ...     c[0] = 5
>>> ... 
>>> func2()
>>> c
>>> [1, 2]
```

在 c = [3, 4] 这句，它是”有歧义的“了，所以它是创建了局部变量 “c” ，而不是引用全局变量 “c” ，所以 c[0] = 5 也是操作的局部变量。

推而远之，这一切现象的本质就是“它是否是明确的”。

仔细想想，就会发现不止 list 不需要global，所有”明确的“东西都不需要global。因为int、str之类的不可变类型，每一次操作就重建新的对象，他们只有一种修改方法，即 x = y ， 恰好这种修改方法同时也是创建变量的方法，所以产生了歧义，不知道是要修改还是创建。而dict、list等可变类型，操作不会重建对象，可以通过 list.append() 或 dict['x']=y 之类的来修改，跟创建变量不冲突，不产生歧义，所以都不用显式global。

### 4.3“ = ”  VS  append/extend

先看如下案例：

```python
>>> list_a = []
>>> def a():
>>> ...     list_a = [1]
>>> ... 
>>> a()
>>> list_a
>>> []

>>> list_b = []
>>> def b():
>>> ...     list_b.append(1)
>>> ... 
>>> b()
>>> list_b
>>> [1]
```

为什么 a() 不能改变 list_a 的值，而 语句 b() 却可以？他们的差别在哪呢？

因为 “=” 创建了局部变量，而 .append() 或者 .extend() 重用了全局变量。

### 4.4默认参数的陷阱

讲到参数传递就不得不提默认参数的陷阱：

```python
>>> def func(val, list=[]):
>>> ...     list.append(val)
>>> ...     return list
>>> ... 
>>> list1 = func(1)
>>> list2 = func(’a‘, [1, 2, 3])
>>> list3 = func('b')
>>> list1
>>> list2
>>> list3
```

这些代码将会输出什么？

```python
>>> def func(val, list=[]):
>>> ...     list.append(val)
>>> ...     return list
>>> ... 
>>> list1 = func(1)
>>> list2 = func("a", [1, 2, 3])
>>> list3 = func('b')
>>> list1
>>> [1, 'b']
>>> list2
>>> [1, 2, 3, 'a']
>>> list3
>>> [1, 'b']
```

许多人会错误的认为 list1 应该等于 [1] 以及 list3 应该等于 ['b']。认为 list 的参数会在 func 每次被调用的时候会被设置成它的默认值 []。

实际发生的事情是，新的默认列表仅仅只在函数被定义时创建一次。随后当 func 没有被指定的列表参数调用的时候，其使用的是同一个列表。这就是为什么当函数被定义的时候，表达式是用默认参数被计算，而不是它被调用的时候。

因此，list1 和 list3 是操作的相同的列表。而 list2 操作的是被传入的独立的列表。

为了到达我们原先的预期，func 函数的定义可以做如下修改：

```python
>>> def func(val, list=None):
>>> ...     if list is None:
>>> ...             list = []
>>> ...     list.append(val)
>>> ...     return list
>>> ... 
>>> list1 = func(1)
>>> list2 = func('a', [1, 2, 3])
>>> list3 = func('b')
>>> list1
>>> [1]
>>> list2
>>> [1, 2, 3, 'a']
>>> list3
>>> ['b']
```

上面的陷阱告诉我们：一定要谨慎使用可变类型的默认参数。

## 5.浅拷贝 VS 深拷贝

### 5.1 浅拷贝

- 浅拷贝是对于一个对象的顶层拷贝. 通俗的理解是：拷贝了引用，并没有拷贝内容

![](/refer/赋值拷贝引用5.png)

![](/refer/赋值拷贝引用6.png)

### 5.2 深拷贝

- 深拷贝是对于一个对象所有层次的拷贝(递归)

![](/refer/赋值拷贝引用7.png)

进一步理解深拷贝

![](/refer/赋值拷贝引用8.png)

![](/refer/赋值拷贝引用9.png)

### 5.3 拷贝的其他方式

- 分片表达式可以赋值一个序列

![](/refer/赋值拷贝引用10.png)

- 字典的copy方法可以拷贝一个字典

![](/refer/赋值拷贝引用11.png)

### 5.4 注意点

**浅拷贝对不可变类型和可变类型的copy不同**

1. copy.copy对于可变类型，会进行浅拷贝
2. copy.copy对于不可变类型，不会拷贝，仅仅是指向

```python
In [88]: a = [11,22,33]
In [89]: b = copy.copy(a)
In [90]: id(a)
Out[90]: 59275144
In [91]: id(b)
Out[91]: 59525600
In [92]: a.append(44)
In [93]: a
Out[93]: [11, 22, 33, 44]
In [94]: b
Out[94]: [11, 22, 33]


In [95]: a = (11,22,33)
In [96]: b = copy.copy(a)
In [97]: id(a)
Out[97]: 58890680
In [98]: id(b)
Out[98]: 58890680
```

![](/refer/赋值拷贝引用12.png)

**copy.copy和copy.deepcopy的区别**

> copy.copy

![](/refer/赋值拷贝引用13.png)

![](/refer/赋值拷贝引用14.png)

> copy.deepcopy

![](/refer/赋值拷贝引用15.png)

![](/refer/赋值拷贝引用16.png)

![](/refer/赋值拷贝引用17.png)

